# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_Functions.ipynb.

# %% auto 0
__all__ = ['read_from_file', 'download_pic', 'create_searches_folder', 'download_search_image', 'download_search_images',
           'verify_pics', 'resize_pics', 'create_data_folder', 'classify_images', 'kaggle_competition_download',
           'kaggle_dataset_download', 'graph']

# %% ../nbs/00_Functions.ipynb 5
def read_from_file(file_path):
    from fastbook import search_images_ddg
    from fastdownload import download_url
    import os
    import shutil
    from PIL import Image
    countries = ()
    with open(file_path, 'r') as file:
        for line in file:
            # Remove any leading/trailing whitespace and newline characters
            country = line.strip()
            # Add the country to the tuple
            countries += (country,)

    return countries

# %% ../nbs/00_Functions.ipynb 7
def download_pic(
    image:str, #image description
    n_images:int=1,
    name:str='', #image name
    folder:str='',   # File path of the image
    show_progress:bool=False,
    recreate:bool=False
): 
    'Downloads the image into the folder provided and displays it'
    assert isinstance(image, str), "image must be a str."
    assert isinstance(name, str), "name must be a str."
    assert isinstance(folder, str), "folder must be a str."
    assert isinstance(n_images, int), "n_images must be an integer."
    assert isinstance(show_progress, bool), "show_progress must be a bool."
    assert isinstance(recreate, bool), "recreate must be a bool."

    from fastbook import search_images_ddg
    from fastdownload import download_url
    import os
    import shutil
    from PIL import Image    
    from pathlib import Path
    from tqdm.notebook import tqdm

    if folder == '':
        folder = Path()
    else:
        folder = Path(folder)
        
    if name == '': name = image

    image_path = f'{folder}/{name}{0}.jpg'
    # Check if the image file exists
    if recreate is False and os.path.exists(image_path):
        print("Image file exists.")
    else:
        search_links = search_images_ddg(
                        f'{image}',
                        max_images=n_images)

        for i in tqdm(range(n_images)): 
            try:
                image_path = f'{folder}/{name}{i}.jpg' 
                if show_progress == True: print(f"Downloading image_path.{i}")
                download_url(
                    search_links[i], image_path,
                    show_progress=show_progress
                )
            except Exception as e:
                # Code to handle any unhandled exceptions
                print("An error occurred:", e)

    return Image.open(image_path).to_thumb(256,256)

# %% ../nbs/00_Functions.ipynb 10
def create_searches_folder(folder_path, searches, show_progress:bool=False):
    from tqdm.notebook import tqdm
    print("Create folder")
    for i in tqdm(searches):
        dest = (folder_path/i)
        dest.mkdir(exist_ok=True, parents=True)
        if show_progress == True: print(f'created {i} folder')

# %% ../nbs/00_Functions.ipynb 11
def download_search_image(folder_path,
                          item,
                          before,
                          after,
                          amount,
                          show_progress:bool=False,
                         ):
    from fastbook import search_images_ddg
    from fastai.vision.all import download_images
    imgAmount = amount
    try:
        urls=search_images_ddg(f'{before}{item}{after}', imgAmount)
        if show_progress == True: print(f"downloading {imgAmount} images for:{before}{item}{after}")

        download_images(
        folder_path/item,
        urls=urls,
        n_workers=16
        )
        
    except Exception as e:
        # Code to handle any unhandled exceptions
        if show_progress == True: print(f"Error with {imgAmount} images of {before}{item}{after}:", e)
        imgAmount -= 20
        if imgAmount > 0: download_search_image(folder_path, item, before, after, imgAmount)

        


# %% ../nbs/00_Functions.ipynb 12
def download_search_images(folder_path,
                           searches,
                           before,
                           after,
                           amount,
                           show_progress:bool=False,
                          ):
    from tqdm.notebook import tqdm
    for item in tqdm(searches):
        imgAmount = amount
        download_search_image(folder_path, item, before, after, amount, show_progress)
            


# %% ../nbs/00_Functions.ipynb 13
def verify_pics(folder_path,
               ):
    from fastai.vision.all import verify_images, get_image_files
    from pathlib import Path
    
    
    failed = verify_images(get_image_files(folder_path))
    failed.map(Path.unlink)
    print(f"Number of images failed: {len(failed)}")

# %% ../nbs/00_Functions.ipynb 14
def resize_pics(folder_path,
                searches,
                max_size=400,
                show:bool=True,
               ):
    from fastai.vision.all import resize_images
    from tqdm.notebook import tqdm
    
    for k in tqdm(searches):
        resize_images(
            folder_path/k,
            max_size=max_size,
            dest=folder_path/k,
            max_workers=16
        )
        if show == True: print(f"resizing images for: {k}")

# %% ../nbs/00_Functions.ipynb 15
def create_data_folder(
    folder_path:str,
    searches:tuple,
    before:str='',
    after:str='',
    amount:int=200,
    recreate:bool=False,
    show_progress:bool=False,
):
    'generate image data'
    assert isinstance(searches, tuple), "searches must be a list."
    assert isinstance(amount, int), "amount must be an int."
    assert isinstance(recreate, bool), "recreate must be a bool."
    assert isinstance(before, str), "before must be a str."
    assert isinstance(after, str), "after must be a str."


    
    from fastdownload import download_url
    from fastai.vision.all import download_images, verify_images
    import os
    import shutil
    from PIL import Image
    from pathlib import Path

    folder_path = Path(folder_path)
    
    if recreate is False and os.path.exists(folder_path):
        print(f"Folder already exists: {folder_path}") 
    else:   
        if recreate is True and os.path.exists(folder_path): 
            shutil.rmtree(folder_path)
        create_searches_folder(folder_path, searches, show_progress)
        download_search_images(folder_path, searches, before, after, amount, show_progress)
        verify_pics(folder_path)
        resize_pics(folder_path, searches)

        

# %% ../nbs/00_Functions.ipynb 18
def classify_images(learn, img):
    'image classifer'
    from fastai.vision.all import PILImage
    
    categories = learn.dls.vocab
    pred,idx,probs = learn.predict(PILImage.create(img))
    rounded_probs = [round(float(prob*100), 5) for prob in probs]
    return dict(zip(categories, rounded_probs))

# %% ../nbs/00_Functions.ipynb 20
def kaggle_competition_download(name:str, folderpath:str = './Data'):
    'download competition files from kaggle'
    import os
    import shutil
    from pathlib import Path

    
    iskaggle = os.environ.get('KAGGLE_KERNEL_RUN_TYPE', '')
    if iskaggle: path = Path(f'../input/{name}')
    else:
        path = Path(f'{folderpath}/{name}')
        if path.exists():print("file exists")
        else:
            import zipfile,kaggle
            kaggle.api.competition_download_cli(competition = name, path = path)
            zipfile.ZipFile(f'{path}/{name}.zip').extractall(path)

# %% ../nbs/00_Functions.ipynb 21
def kaggle_dataset_download(user:str,
                            name:str,
                            folderpath:str = './Data'):
    'download competition files from kaggle'
    import os
    import shutil
    from pathlib import Path

    iskaggle = os.environ.get('KAGGLE_KERNEL_RUN_TYPE', '')
    if iskaggle: path = Path(f'../input/{name}')
    else:
        path = Path(f'{folderpath}/{name}')
        if path.exists():print("file exists")
        else:
            import zipfile,kaggle
            kaggle.api.dataset_download_files(dataset = f'{user}/{name}', path = path)
            zipfile.ZipFile(f'{path}/{name}.zip').extractall(path)

# %% ../nbs/00_Functions.ipynb 23
from graphviz import Digraph

# %% ../nbs/00_Functions.ipynb 24
class graph(Digraph):
    def __init__(self, *args, **kwargs):
        # Call the superclass's __init__ method using super() and pass all arguments
        super().__init__(*args, **kwargs)
        self.primary = '#fdfcdc'
        self.secondary = '#fcbf49'
        self.third = '#f77f00'
        self.fourth = '#d62828'
        self.fifth = '#003049'

        
        self.graph_attr.update(style='rounded,filled',
                               rankdir='LR',
                               compound='true',
                               fillcolor=self.fourth,
                               fontcolor=self.fifth,
                               penwidth = '0',
                               fontname = "Helvetica,Arial,sans-serif")
        
        self.node_attr.update(style='rounded,filled',
                              size='8,5', shape='box',
                              width='1.5',
                              fillcolor=self.secondary,
                              fontcolor=self.fifth,
                              penwidth = '0',
                              fontname = "Helvetica,Arial,sans-serif") 
        
        self.edge_attr.update(arrowhead='vee',
                              arrowsize='1',
                              color=self.fifth,
                              len='1.00',
                              fontname = "Helvetica,Arial,sans-serif",
                              penwidth='1')
        self.graph_attr.update()
        
