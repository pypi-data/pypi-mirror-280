# yapf: disable
# isort: skip_file
# ruff: noqa

# Standard imports.
from __future__ import annotations

import asyncio
import dataclasses
import google.protobuf.descriptor
import google.protobuf.json_format
import google.protobuf.message
import grpc
import json
import logging
import sys
import traceback
import uuid
import resemble
import respect.logging  # type: ignore[import]
import typing
from abc import abstractmethod
from backoff import Backoff
from datetime import datetime, timedelta
from google.protobuf import empty_pb2
from google.rpc import status_pb2
from grpc_status import rpc_status
from resemble.aio.call import InvalidActorIdError, MixedContextsError
from resemble.aio.contexts import (
    Context,
    EffectValidationRetry,
    ReaderContext,
    TransactionContext,
    WorkflowContext,
    WriterContext,
    EffectValidation,
)
from resemble.aio.headers import Headers
from resemble.aio.idempotency import IdempotencyManager, Idempotency
from resemble.aio.internals.channel_manager import _ChannelManager
from resemble.aio.internals.middleware import (
    maybe_run_function_twice_to_validate_effects,
    maybe_run_method_twice_to_validate_effects,
    Middleware,
)
from resemble.aio.internals.tasks_cache import TasksCache
from resemble.aio.internals.tasks_dispatcher import TasksDispatcher
from resemble.aio.headers import Headers
from resemble.aio.servicers import Servicer, Serviceable
from resemble.aio.state_managers import Effects, StateManager
from resemble.aio.stubs import Stub
from resemble.aio.tasks import TaskEffect
from resemble.aio.types import (
    ActorId,
    ApplicationId,
    assert_type,
    GrpcMetadata,
    ServiceName,
    state_type_to_service,
)
from resemble.aio.workflows import Workflow
from resemble.settings import MAX_ACTOR_ID_LENGTH
from resemble.v1alpha1 import tasks_pb2, tasks_pb2_grpc
from typing import (
    cast,
    Any,
    AsyncIterable,
    AsyncIterator,
    Awaitable,
    Callable,
    Generator,
    NoReturn,
    Optional,
    TypeAlias,
    Union,
)

# User defined or referenced imports.
import resemble.cloud.v1alpha1.application.application_pb2
import resemble.cloud.v1alpha1.application.application_pb2_grpc
import resemble.v1alpha1.options_pb2
import resemble.v1alpha1.tasks_pb2
# Additionally re-export all messages and enums from the pb2 module.
from resemble.cloud.v1alpha1.application.application_pb2 import (
    CreateRequest,
    CreateResponse,
    DownRequest,
    DownResponse,
    DownTaskRequest,
    DownTaskResponse,
    InvalidInputError,
    Permissions,
    UpRequest,
    UpResponse,
    UpTaskResponse,
)

logger = respect.logging.get_logger(__name__)


def MakeLegacyGrpcServiceable(
    # A legacy gRPC servicer type can't be more specific than `type`,
    # because legacy gRPC servicers (as generated by the gRPC `protoc`
    # plugin) do not share any common base class other than `object`.
    servicer_type: type
) -> Serviceable:
    raise ValueError(f"Unknown legacy gRPC servicer type '{servicer_type}'")


# For internal calls, we can use a magic token to bypass token verification and
# authorization checks. The token provides no auth information (e.g.,
# `context.auth is None`).
__internal_magic_token__: str = f'internal-{str(uuid.uuid4())}'

class ApplicationServicerMiddleware(Middleware):

    def __init__(
        self,
        *,
        servicer: ApplicationServicer,
        application_id: ApplicationId,
        state_manager: StateManager,
        channel_manager: _ChannelManager,
        tasks_cache: TasksCache,
        token_verifier: Optional[resemble.aio.auth.token_verifiers.TokenVerifier],
        effect_validation: EffectValidation,
        ready: asyncio.Event,
    ):
        super().__init__(
            application_id=application_id,
            service_name=servicer.__service_name__,
            channel_manager=channel_manager,
            effect_validation=effect_validation,
        )

        self._servicer = servicer
        self._state_manager = state_manager
        self.tasks_dispatcher = TasksDispatcher(
            application_id=application_id,
            dispatch=self.dispatch,
            tasks_cache=tasks_cache,
            ready=ready,
        )

        # Store the type of each method's request so that stored requests can be
        # deserialized into the correct type.
        self.request_type_by_method_name: dict[str, type[google.protobuf.message.Message]] = {
            'Create': resemble.cloud.v1alpha1.application.application_pb2.CreateRequest,
            'Up': resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
            'UpTask': resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
            'Down': resemble.cloud.v1alpha1.application.application_pb2.DownRequest,
            'DownTask': resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest,
        }

        # Create authorizer.
        self._authorizer: Optional[resemble.aio.auth.authorizers.Authorizer] = servicer.authorizer()

        # Create token verifier.
        self._token_verifier: Optional[resemble.aio.auth.token_verifiers.TokenVerifier] = (
            servicer.token_verifier() or token_verifier
        )

        if self._token_verifier is not None and self._authorizer is None:
            raise RuntimeError(
                f"'TokenVerifier' provided but no 'Authorizer' returned for "
                f"'resemble.cloud.v1alpha1.application.Application'"
            )

    def add_to_server(self, server: grpc.aio.Server) -> None:
        resemble.cloud.v1alpha1.application.application_pb2_grpc.add_ApplicationInterfaceServicer_to_server(
            self, server
        )

    async def inspect(self, actor_id: ActorId) -> AsyncIterator[google.protobuf.message.Message]:
        """Implementation of `Middleware.inspect()`."""
        context = self.create_context(
            headers=Headers(
                application_id=self.application_id,
                service_name=self.service_name,
                actor_id=actor_id,
            ),
            context_type=ReaderContext,
        )

        async with self._state_manager.streaming_reader_idempotency_key(
            context, self._servicer.__state_type__
        ) as states:
            async for (state, idempotency_key) in states:
                yield state

    async def react_query(
        self,
        grpc_context: grpc.aio.ServicerContext,
        headers: Headers,
        method: str,
        request_bytes: bytes,
    ) -> AsyncIterator[tuple[Optional[google.protobuf.message.Message], list[uuid.UUID]]]:
        """Returns the response of calling 'method' given a message
        deserialized from the provided 'request_bytes' for each state
        update that creates a different response.

        NOTE: only unary reader methods are supported."""
        # Need to define these up here since we can only do that once.
        last_response: Optional[google.protobuf.message.Message] = None
        aggregated_idempotency_keys: list[uuid.UUID] = []
        if method == 'Create':
            # Invariant here is that users should not have called this
            # directly but only through code generated React
            # components which should not have been generated except
            # for valid method candidates.
            logger.warning(
                "Got a React query request with an invalid method name: "
                f"Method '{method}' is invalid for servicer Application."
                "\n"
                "Do you have a browser tab open for an older version "
                "of this application, or for a different application all together?"
            )
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.InvalidMethod(),
                message=
                    f"Method '{method}' is invalid"
            )
            yield  # Necessary for type checking.
        elif method == 'Up':
            # Invariant here is that users should not have called this
            # directly but only through code generated React
            # components which should not have been generated except
            # for valid method candidates.
            logger.warning(
                "Got a React query request with an invalid method name: "
                f"Method '{method}' is invalid for servicer Application."
                "\n"
                "Do you have a browser tab open for an older version "
                "of this application, or for a different application all together?"
            )
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.InvalidMethod(),
                message=
                    f"Method '{method}' is invalid"
            )
            yield  # Necessary for type checking.
        elif method == 'UpTask':
            # Invariant here is that users should not have called this
            # directly but only through code generated React
            # components which should not have been generated except
            # for valid method candidates.
            logger.warning(
                "Got a React query request with an invalid method name: "
                f"Method '{method}' is invalid for servicer Application."
                "\n"
                "Do you have a browser tab open for an older version "
                "of this application, or for a different application all together?"
            )
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.InvalidMethod(),
                message=
                    f"Method '{method}' is invalid"
            )
            yield  # Necessary for type checking.
        elif method == 'Down':
            # Invariant here is that users should not have called this
            # directly but only through code generated React
            # components which should not have been generated except
            # for valid method candidates.
            logger.warning(
                "Got a React query request with an invalid method name: "
                f"Method '{method}' is invalid for servicer Application."
                "\n"
                "Do you have a browser tab open for an older version "
                "of this application, or for a different application all together?"
            )
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.InvalidMethod(),
                message=
                    f"Method '{method}' is invalid"
            )
            yield  # Necessary for type checking.
        elif method == 'DownTask':
            # Invariant here is that users should not have called this
            # directly but only through code generated React
            # components which should not have been generated except
            # for valid method candidates.
            logger.warning(
                "Got a React query request with an invalid method name: "
                f"Method '{method}' is invalid for servicer Application."
                "\n"
                "Do you have a browser tab open for an older version "
                "of this application, or for a different application all together?"
            )
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.InvalidMethod(),
                message=
                    f"Method '{method}' is invalid"
            )
            yield  # Necessary for type checking.
        else:
            logger.warning(
                "Got a React query request with an invalid method name: "
                "Method '{method}' is invalid for servicer Application."
                "\n"
                "Do you have a browser tab open for an older version "
                "of this application, or for a different application all together?"
            )
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.InvalidMethod(),
                message=
                    f"Method '{method}' not found"
            )
            yield  # Unreachable but necessary for mypy.

    @maybe_run_method_twice_to_validate_effects
    async def react_mutate(
        self,
        validating_effects: bool,
        headers: Headers,
        method: str,
        request_bytes: bytes,
    ) -> google.protobuf.message.Message:
        """Returns the response of calling 'method' given a message
        deserialized from the provided 'request_bytes'."""
        if method == 'Create':
            request = resemble.cloud.v1alpha1.application.application_pb2.CreateRequest()
            request.ParseFromString(request_bytes)

            # NOTE: we automatically retry mutations that come through
            # React when we get a `grpc.StatusCode.UNAVAILABLE` to
            # match the retry logic we do in the React code generated
            # to handle lack/loss of connectivity.
            #
            # TODO(benh): revisit this decision if we ever see reason
            # to call `react_mutate()` from any place other than where
            # we're executing React (e.g., browser, next.js server
            # component, etc).
            backoff = Backoff()
            while True:
                try:
                    return await self._Create(
                        request,
                        self.create_context(
                            headers=headers,
                            context_type=WriterContext,
                        ),
                        validating_effects=validating_effects,
                    )
                except resemble.aio.aborted.Aborted as aborted:
                    if aborted.code == grpc.StatusCode.UNAVAILABLE:
                        await backoff()
                        continue
                    raise
        elif method == 'Up':
            request = resemble.cloud.v1alpha1.application.application_pb2.UpRequest()
            request.ParseFromString(request_bytes)

            # NOTE: we automatically retry mutations that come through
            # React when we get a `grpc.StatusCode.UNAVAILABLE` to
            # match the retry logic we do in the React code generated
            # to handle lack/loss of connectivity.
            #
            # TODO(benh): revisit this decision if we ever see reason
            # to call `react_mutate()` from any place other than where
            # we're executing React (e.g., browser, next.js server
            # component, etc).
            backoff = Backoff()
            while True:
                try:
                    return await self._Up(
                        request,
                        self.create_context(
                            headers=headers,
                            context_type=WriterContext,
                        ),
                        validating_effects=validating_effects,
                    )
                except resemble.aio.aborted.Aborted as aborted:
                    if aborted.code == grpc.StatusCode.UNAVAILABLE:
                        await backoff()
                        continue
                    raise
        elif method == 'UpTask':
            request = resemble.cloud.v1alpha1.application.application_pb2.UpRequest()
            request.ParseFromString(request_bytes)

            # NOTE: we automatically retry mutations that come through
            # React when we get a `grpc.StatusCode.UNAVAILABLE` to
            # match the retry logic we do in the React code generated
            # to handle lack/loss of connectivity.
            #
            # TODO(benh): revisit this decision if we ever see reason
            # to call `react_mutate()` from any place other than where
            # we're executing React (e.g., browser, next.js server
            # component, etc).
            backoff = Backoff()
            while True:
                try:
                    return await self._UpTask(
                        request,
                        self.create_context(
                            headers=headers,
                            context_type=WriterContext,
                        ),
                        validating_effects=validating_effects,
                    )
                except resemble.aio.aborted.Aborted as aborted:
                    if aborted.code == grpc.StatusCode.UNAVAILABLE:
                        await backoff()
                        continue
                    raise
        elif method == 'Down':
            request = resemble.cloud.v1alpha1.application.application_pb2.DownRequest()
            request.ParseFromString(request_bytes)

            # NOTE: we automatically retry mutations that come through
            # React when we get a `grpc.StatusCode.UNAVAILABLE` to
            # match the retry logic we do in the React code generated
            # to handle lack/loss of connectivity.
            #
            # TODO(benh): revisit this decision if we ever see reason
            # to call `react_mutate()` from any place other than where
            # we're executing React (e.g., browser, next.js server
            # component, etc).
            backoff = Backoff()
            while True:
                try:
                    return await self._Down(
                        request,
                        self.create_context(
                            headers=headers,
                            context_type=WriterContext,
                        ),
                        validating_effects=validating_effects,
                    )
                except resemble.aio.aborted.Aborted as aborted:
                    if aborted.code == grpc.StatusCode.UNAVAILABLE:
                        await backoff()
                        continue
                    raise
        elif method == 'DownTask':
            request = resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest()
            request.ParseFromString(request_bytes)

            # NOTE: we automatically retry mutations that come through
            # React when we get a `grpc.StatusCode.UNAVAILABLE` to
            # match the retry logic we do in the React code generated
            # to handle lack/loss of connectivity.
            #
            # TODO(benh): revisit this decision if we ever see reason
            # to call `react_mutate()` from any place other than where
            # we're executing React (e.g., browser, next.js server
            # component, etc).
            backoff = Backoff()
            while True:
                try:
                    return await self._DownTask(
                        request,
                        self.create_context(
                            headers=headers,
                            context_type=WriterContext,
                        ),
                        validating_effects=validating_effects,
                    )
                except resemble.aio.aborted.Aborted as aborted:
                    if aborted.code == grpc.StatusCode.UNAVAILABLE:
                        await backoff()
                        continue
                    raise
        else:
            logger.warning(
                "Got a react mutate request with an invalid method name: "
                "Method '{method}' is invalid for servicer Application."
                "\n"
                "Do you have an old browser tab still open for an older version "
                "of this application, or a different application all together?"
            )
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.InvalidMethod(),
                message=
                    f"Method '{method}' not found"
            )

    async def dispatch(
        self,
        task: TaskEffect,
        *,
        only_validate: bool = False,
    ) -> google.protobuf.message.Message | resemble.aio.tasks.Loop:
        """Dispatches the tasks to execute unless 'only_validate' is set to
        true, in which case just ensures that the task actually exists.
        Note that this function will be called *by* tasks_dispatcher; it will
        not itself call into tasks_dispatcher."""

        if 'Create' == task.method_name:
            if only_validate:
                # TODO(benh): validate 'task.request' is correct type.
                return resemble.cloud.v1alpha1.application.application_pb2.CreateResponse()

            # Use an inline method to create a new scope, so that we can use
            # variable names like `context` and `effects` in multiple branches
            # in this code (notably when there are multiple task types) without
            # hitting a mypy error that the variable's type is not consistent.
            @maybe_run_function_twice_to_validate_effects
            async def run_Create(
                validating_effects: bool,
                context: WorkflowContext,
            ):
                async with self._state_manager.task_workflow(
                    context,
                ) as complete:
                    response = await (ApplicationWorkflowStub(
                        context_or_workflow=context,
                        actor_id=context.actor_id,
                    ).Create(
                        cast(resemble.cloud.v1alpha1.application.application_pb2.CreateRequest, task.request),
                        bearer_token=__internal_magic_token__,
                        idempotency=Idempotency(
                            alias=f'Task {task.task_id.task_uuid}',
                        ),
                    ))

                    await complete(task, response)
                    return response




            return await run_Create(
                self.create_context(
                    headers=Headers(
                        application_id=self.application_id,
                        service_name=self.service_name,
                        actor_id=task.task_id.actor_id,
                    ),
                    context_type=WorkflowContext,
                    task=task,
                )
            )
        elif 'Up' == task.method_name:
            if only_validate:
                # TODO(benh): validate 'task.request' is correct type.
                return resemble.cloud.v1alpha1.application.application_pb2.UpResponse()

            # Use an inline method to create a new scope, so that we can use
            # variable names like `context` and `effects` in multiple branches
            # in this code (notably when there are multiple task types) without
            # hitting a mypy error that the variable's type is not consistent.
            @maybe_run_function_twice_to_validate_effects
            async def run_Up(
                validating_effects: bool,
                context: WorkflowContext,
            ):
                async with self._state_manager.task_workflow(
                    context,
                ) as complete:
                    response = await (ApplicationWorkflowStub(
                        context_or_workflow=context,
                        actor_id=context.actor_id,
                    ).Up(
                        cast(resemble.cloud.v1alpha1.application.application_pb2.UpRequest, task.request),
                        bearer_token=__internal_magic_token__,
                        idempotency=Idempotency(
                            alias=f'Task {task.task_id.task_uuid}',
                        ),
                    ))

                    await complete(task, response)
                    return response




            return await run_Up(
                self.create_context(
                    headers=Headers(
                        application_id=self.application_id,
                        service_name=self.service_name,
                        actor_id=task.task_id.actor_id,
                    ),
                    context_type=WorkflowContext,
                    task=task,
                )
            )
        elif 'UpTask' == task.method_name:
            if only_validate:
                # TODO(benh): validate 'task.request' is correct type.
                return resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse()

            # Use an inline method to create a new scope, so that we can use
            # variable names like `context` and `effects` in multiple branches
            # in this code (notably when there are multiple task types) without
            # hitting a mypy error that the variable's type is not consistent.
            @maybe_run_function_twice_to_validate_effects
            async def run_UpTask(
                validating_effects: bool,
                context: WorkflowContext,
            ):
                async with self._state_manager.task_workflow(
                    context,
                ) as complete:
                    response = await (ApplicationWorkflowStub(
                        context_or_workflow=context,
                        actor_id=context.actor_id,
                    ).UpTask(
                        cast(resemble.cloud.v1alpha1.application.application_pb2.UpRequest, task.request),
                        bearer_token=__internal_magic_token__,
                        idempotency=Idempotency(
                            alias=f'Task {task.task_id.task_uuid}',
                        ),
                    ))

                    await complete(task, response)
                    return response




            return await run_UpTask(
                self.create_context(
                    headers=Headers(
                        application_id=self.application_id,
                        service_name=self.service_name,
                        actor_id=task.task_id.actor_id,
                    ),
                    context_type=WorkflowContext,
                    task=task,
                )
            )
        elif 'Down' == task.method_name:
            if only_validate:
                # TODO(benh): validate 'task.request' is correct type.
                return resemble.cloud.v1alpha1.application.application_pb2.DownResponse()

            # Use an inline method to create a new scope, so that we can use
            # variable names like `context` and `effects` in multiple branches
            # in this code (notably when there are multiple task types) without
            # hitting a mypy error that the variable's type is not consistent.
            @maybe_run_function_twice_to_validate_effects
            async def run_Down(
                validating_effects: bool,
                context: WorkflowContext,
            ):
                async with self._state_manager.task_workflow(
                    context,
                ) as complete:
                    response = await (ApplicationWorkflowStub(
                        context_or_workflow=context,
                        actor_id=context.actor_id,
                    ).Down(
                        cast(resemble.cloud.v1alpha1.application.application_pb2.DownRequest, task.request),
                        bearer_token=__internal_magic_token__,
                        idempotency=Idempotency(
                            alias=f'Task {task.task_id.task_uuid}',
                        ),
                    ))

                    await complete(task, response)
                    return response




            return await run_Down(
                self.create_context(
                    headers=Headers(
                        application_id=self.application_id,
                        service_name=self.service_name,
                        actor_id=task.task_id.actor_id,
                    ),
                    context_type=WorkflowContext,
                    task=task,
                )
            )
        elif 'DownTask' == task.method_name:
            if only_validate:
                # TODO(benh): validate 'task.request' is correct type.
                return resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse()

            # Use an inline method to create a new scope, so that we can use
            # variable names like `context` and `effects` in multiple branches
            # in this code (notably when there are multiple task types) without
            # hitting a mypy error that the variable's type is not consistent.
            @maybe_run_function_twice_to_validate_effects
            async def run_DownTask(
                validating_effects: bool,
                context: WorkflowContext,
            ):
                async with self._state_manager.task_workflow(
                    context,
                ) as complete:
                    response = await (ApplicationWorkflowStub(
                        context_or_workflow=context,
                        actor_id=context.actor_id,
                    ).DownTask(
                        cast(resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest, task.request),
                        bearer_token=__internal_magic_token__,
                        idempotency=Idempotency(
                            alias=f'Task {task.task_id.task_uuid}',
                        ),
                    ))

                    await complete(task, response)
                    return response




            return await run_DownTask(
                self.create_context(
                    headers=Headers(
                        application_id=self.application_id,
                        service_name=self.service_name,
                        actor_id=task.task_id.actor_id,
                    ),
                    context_type=WorkflowContext,
                    task=task,
                )
            )

        # There are no tasks for this service.
        start_or_validate = "start" if not only_validate else "validate"
        raise RuntimeError(
            f"Attempted to {start_or_validate} task '{task.method_name}' "
            f"on 'Application' which does not exist"
        )

    # Application specific methods:
    async def __Create(
        self,
        context: WriterContext,
        request: resemble.cloud.v1alpha1.application.application_pb2.CreateRequest,
        *,
        validating_effects: bool,
    ) -> Application.CreateEffects:
        try:
            response = (
                await self._servicer.Create(
                    context=context,
                    request=request
                )
            )
            self.maybe_raise_effect_validation_retry(
                logger=logger,
                idempotency_manager=context,
                method_name='Application.Create',
                validating_effects=validating_effects,
                context=context,
            )
            return response
        except resemble.aio.contexts.RetryReactively:
            # Retrying reactively, just let this propagate.
            raise
        except EffectValidationRetry:
            # Doing effect validation, just let this propagate.
            raise
        except resemble.aio.aborted.Aborted as aborted:
            # Log any _unhandled_ abort stack traces to make it
            # easier for debugging.
            #
            # NOTE: we don't log if we're a task as it will be logged
            # in `resemble/aio/internals/tasks_dispatcher.py` instead.
            aborted_type: Optional[type] = None
            aborted_type = Application.CreateAborted
            if isinstance(aborted, resemble.aio.aborted.SystemAborted):
                if context.task is None:
                    logger.warning(
                        f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.Create') {aborted}; propagating as 'Unknown'\n" +
                        ''.join(traceback.format_exception(aborted))
                    )
                raise resemble.aio.aborted.SystemAborted(
                    resemble.v1alpha1.errors_pb2.Unknown(),
                    # TODO(benh): consider whether or not we want to
                    # include the 'package.service.method' which may
                    # get concatenated together forming a kind of
                    # "stack trace"; while it's super helpful for
                    # debugging, it does expose implementation
                    # information.
                    message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.Create') {aborted}"
                )
            else:
                if (
                    aborted_type is not None and
                    not isinstance(aborted, aborted_type) and
                    aborted_type.is_declared_error(aborted.error)
                ):
                    if context.task is None:
                        logger.warning(
                            f"Propagating unhandled (in 'resemble.cloud.v1alpha1.application.Application.Create') {aborted}"
                        )
                elif (
                    aborted_type is None or
                    not isinstance(aborted, aborted_type)
                ):
                    if context.task is None:
                        logger.warning(
                            f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.Create') {aborted}; propagating as 'Unknown'\n" +
                            ''.join(traceback.format_exception(aborted))
                        )
                    raise resemble.aio.aborted.SystemAborted(
                        resemble.v1alpha1.errors_pb2.Unknown(),
                        # TODO(benh): consider whether or not we want to
                        # include the 'package.service.method' which may
                        # get concatenated together forming a kind of
                        # "stack trace"; while it's super helpful for
                        # debugging, it does expose implementation
                        # information.
                        message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.Create') {aborted}"
                    )

            raise
        except asyncio.CancelledError:
            # It's pretty normal for an RPC to be cancelled; it's not useful to
            # print a stack trace.
            raise
        except BaseException as exception:
            if context.task is None:
                logger.warning(
                    f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.Create') {type(exception).__name__}: {exception}; propagating as 'Unknown'\n" +
                    ''.join(traceback.format_exception(exception))
                )
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.Unknown(),
                # TODO(benh): consider whether or not we want to
                # include the 'package.service.method' which may
                # get concatenated together forming a kind of
                # "stack trace"; while it's super helpful for
                # debugging, it does expose implementation
                # information.
                message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.Create') {type(exception).__name__}: {exception}"
            )

    async def _Create(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.CreateRequest,
        context: WriterContext,
        *,
        validating_effects: bool,
        grpc_context: Optional[grpc.aio.ServicerContext] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.CreateResponse:
        # Try to verify the token if a token verifier exists.
        context.auth = await self._maybe_verify_token(context._headers)

        # Check if we already have performed this mutation!
        #
        # We do this _before_ calling 'transactionally()' because
        # if this call is for a transaction method _and_ we've
        # already performed the transaction then we don't want to
        # become a transaction participant (again) we just want to
        # return the transaction's response.
        idempotent_mutation = self._state_manager.check_for_idempotent_mutation(
            context
        )

        if idempotent_mutation is not None:
            response = resemble.cloud.v1alpha1.application.application_pb2.CreateResponse()
            response.ParseFromString(idempotent_mutation.response)
            return response

        async with self._state_manager.transactionally(
            context, self.tasks_dispatcher
        ) as transaction:
            if transaction is not None:
                context.participants.add(
                    self._servicer.__service_name__, context.actor_id
                )
            # TODO: this loads a `state` object even when we know we're calling a constructor,
            # in which case (by definition) there is no state. Can we (and is it worth
            # the effort to) change this call to avoid that overhead in that case?
            async with self._state_manager.writer(
                context,
                self._servicer.__state_type__,
                transaction=transaction,
                from_constructor=True,
                requires_constructor=True
            ) as (state, writer):

                await self._maybe_authorize(
                    method_name=
                    'resemble.cloud.v1alpha1.application.Application.Create',
                    headers=context._headers,
                    auth=context.auth,
                    request=request,
                )

                effects = await self.__Create(
                    context,
                    request,
                    validating_effects=validating_effects,
                )

                if effects.tasks is not None:
                    # NOTE: we validate tasks added as part of a
                    # transaction when we prepare.
                    if transaction is None:
                        await self.tasks_dispatcher.validate(
                            effects.tasks
                        )

                await writer.complete(effects)

                if effects.tasks is not None:
                    if transaction is None:
                        self.tasks_dispatcher.dispatch(effects.tasks)
                    else:
                        assert all(
                            task.task_id.state_type == transaction.state_type
                            for task in effects.tasks
                        ), 'Task state type does not match transaction state type'
                        transaction.tasks.extend(effects.tasks)

                # TODO: We need a single `Effects` superclass for all methods, so we
                # would need to make it "partially" generic (with per-method subclasses
                # filling out the rest of the generic parameters) in order to fix this.
                return effects.response  # type: ignore[return-value]

    async def _schedule_Create(
        self,
        *,
        request: resemble.cloud.v1alpha1.application.application_pb2.CreateRequest,
        headers: Headers,
        grpc_context: grpc.aio.ServicerContext,
    ) -> tuple[WriterContext, resemble.cloud.v1alpha1.application.application_pb2.CreateResponse]:
        context: WriterContext = self.create_context(
            headers=headers,
            context_type=WriterContext,
        )
        response = resemble.cloud.v1alpha1.application.application_pb2.CreateResponse()

        # Check if we already have performed this mutation!
        #
        # We do this _before_ calling 'transactionally()' because
        # if this call is for a transaction method _and_ we've
        # already performed the transaction then we don't want to
        # become a transaction participant (again) we just want to
        # return the transaction's response.
        idempotent_mutation = self._state_manager.check_for_idempotent_mutation(
            context
        )

        if idempotent_mutation is not None:
            response.ParseFromString(idempotent_mutation.response)

            # We should have only scheduled a single task!
            assert len(idempotent_mutation.task_ids) == 1
            assert grpc_context is not None
            grpc_context.set_trailing_metadata(
                grpc_context.trailing_metadata() +
                (
                    (
                        resemble.aio.headers.TASK_ID_UUID,
                        str(uuid.UUID(bytes=idempotent_mutation.task_ids[0].task_uuid))
                    ),
                )
            )

            return context, response

        async with self._state_manager.transactionally(
            context, self.tasks_dispatcher
        ) as transaction:
            if transaction is not None:
                context.participants.add(
                    self._servicer.__service_name__, context.actor_id
                )
            async with self._state_manager.writer(
                context,
                self._servicer.__state_type__,
                transaction=transaction,
                from_constructor=True,
                requires_constructor=True
            ) as (state, writer):

                # Try to verify the token if a token verifier exists.
                context.auth = await self._maybe_verify_token(headers)

                # Check if we are allowed schedule the task.
                await self._maybe_authorize(
                    method_name=
                    'resemble.cloud.v1alpha1.application.Application.Create',
                    headers=context._headers,
                    auth=context.auth,
                    request=request,
                )

                task = ApplicationServicerTasksStub(
                    context=context,
                    actor_id=context.actor_id,
                ).Create(
                    request,
                    schedule=context._headers.task_schedule,
                )

                effects = Effects(
                    response=response,
                    state=state,
                    tasks=[task],
                )

                assert effects.tasks is not None

                # NOTE: we validate tasks added as part of a
                # transaction when we prepare.
                if transaction is None:
                    await self.tasks_dispatcher.validate(effects.tasks)

                await writer.complete(effects)

                if transaction is None:
                    self.tasks_dispatcher.dispatch(effects.tasks)
                else:
                    assert task.task_id.state_type == transaction.state_type
                    transaction.tasks.extend(effects.tasks)

                assert grpc_context is not None

                grpc_context.set_trailing_metadata(
                    grpc_context.trailing_metadata() +
                    (
                        (
                            resemble.aio.headers.TASK_ID_UUID,
                            str(uuid.UUID(bytes=task.task_id.task_uuid))
                        ),
                    )
                )

                return context, response

        return context, response


    @maybe_run_method_twice_to_validate_effects
    async def Create(
        self,
        validating_effects: bool,
        request: resemble.cloud.v1alpha1.application.application_pb2.CreateRequest,
        grpc_context: grpc.aio.ServicerContext,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.CreateResponse:
        context: Optional[Context] = None
        try:
            headers = Headers.from_grpc_context(grpc_context)
            if headers.task_schedule is not None:
                context, response = await self._schedule_Create(
                    headers=headers,
                    request=request,
                    grpc_context=grpc_context,
                )
                return response

            context = self.create_context(
                headers=headers,
                context_type=WriterContext,
            )
            assert context is not None

            return await self._Create(
                request,
                context,
                validating_effects=validating_effects,
                grpc_context=grpc_context,
            )
        except EffectValidationRetry:
            # Doing effect validation, just let this propagate.
            raise
        except resemble.aio.aborted.Aborted as aborted:
            await grpc_context.abort_with_status(
                rpc_status.to_status(aborted.to_status())
            )
            raise  # Unreachable but necessary for mypy.
        except asyncio.CancelledError:
            # It's pretty normal for an RPC to be cancelled; it's not useful to
            # print a stack trace.
            raise
        except:
            # Print the exception stack trace for easier debugging. Note
            # that we don't include the stack trace in an error message
            # for the same reason that gRPC doesn't do so by default,
            # see https://github.com/grpc/grpc/issues/14897, but since this
            # should only get logged on the server side it is safe.
            logger.warning(
                'Unhandled exception\n' +
                ''.join(traceback.format_exc())
            )

            # Re-raise the exception for gRPC to handle!
            raise
        finally:
            if context is not None and context.transaction_id is not None:
                # Propagate transaction participants.
                grpc_context.set_trailing_metadata(
                    grpc_context.trailing_metadata() +
                    context.participants.to_grpc_metadata()
                )

    async def __Up(
        self,
        context: WriterContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        *,
        validating_effects: bool,
    ) -> Application.UpEffects:
        try:
            response = (
                await self._servicer.Up(
                    context=context,
                    state=state,
                    request=request
                )
            )
            self.maybe_raise_effect_validation_retry(
                logger=logger,
                idempotency_manager=context,
                method_name='Application.Up',
                validating_effects=validating_effects,
                context=context,
            )
            return response
        except resemble.aio.contexts.RetryReactively:
            # Retrying reactively, just let this propagate.
            raise
        except EffectValidationRetry:
            # Doing effect validation, just let this propagate.
            raise
        except resemble.aio.aborted.Aborted as aborted:
            # Log any _unhandled_ abort stack traces to make it
            # easier for debugging.
            #
            # NOTE: we don't log if we're a task as it will be logged
            # in `resemble/aio/internals/tasks_dispatcher.py` instead.
            aborted_type: Optional[type] = None
            aborted_type = Application.UpAborted
            if isinstance(aborted, resemble.aio.aborted.SystemAborted):
                if context.task is None:
                    logger.warning(
                        f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.Up') {aborted}; propagating as 'Unknown'\n" +
                        ''.join(traceback.format_exception(aborted))
                    )
                raise resemble.aio.aborted.SystemAborted(
                    resemble.v1alpha1.errors_pb2.Unknown(),
                    # TODO(benh): consider whether or not we want to
                    # include the 'package.service.method' which may
                    # get concatenated together forming a kind of
                    # "stack trace"; while it's super helpful for
                    # debugging, it does expose implementation
                    # information.
                    message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.Up') {aborted}"
                )
            else:
                if (
                    aborted_type is not None and
                    not isinstance(aborted, aborted_type) and
                    aborted_type.is_declared_error(aborted.error)
                ):
                    if context.task is None:
                        logger.warning(
                            f"Propagating unhandled (in 'resemble.cloud.v1alpha1.application.Application.Up') {aborted}"
                        )
                elif (
                    aborted_type is None or
                    not isinstance(aborted, aborted_type)
                ):
                    if context.task is None:
                        logger.warning(
                            f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.Up') {aborted}; propagating as 'Unknown'\n" +
                            ''.join(traceback.format_exception(aborted))
                        )
                    raise resemble.aio.aborted.SystemAborted(
                        resemble.v1alpha1.errors_pb2.Unknown(),
                        # TODO(benh): consider whether or not we want to
                        # include the 'package.service.method' which may
                        # get concatenated together forming a kind of
                        # "stack trace"; while it's super helpful for
                        # debugging, it does expose implementation
                        # information.
                        message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.Up') {aborted}"
                    )

            raise
        except asyncio.CancelledError:
            # It's pretty normal for an RPC to be cancelled; it's not useful to
            # print a stack trace.
            raise
        except BaseException as exception:
            if context.task is None:
                logger.warning(
                    f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.Up') {type(exception).__name__}: {exception}; propagating as 'Unknown'\n" +
                    ''.join(traceback.format_exception(exception))
                )
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.Unknown(),
                # TODO(benh): consider whether or not we want to
                # include the 'package.service.method' which may
                # get concatenated together forming a kind of
                # "stack trace"; while it's super helpful for
                # debugging, it does expose implementation
                # information.
                message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.Up') {type(exception).__name__}: {exception}"
            )

    async def _Up(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        context: WriterContext,
        *,
        validating_effects: bool,
        grpc_context: Optional[grpc.aio.ServicerContext] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.UpResponse:
        # Try to verify the token if a token verifier exists.
        context.auth = await self._maybe_verify_token(context._headers)

        # Check if we already have performed this mutation!
        #
        # We do this _before_ calling 'transactionally()' because
        # if this call is for a transaction method _and_ we've
        # already performed the transaction then we don't want to
        # become a transaction participant (again) we just want to
        # return the transaction's response.
        idempotent_mutation = self._state_manager.check_for_idempotent_mutation(
            context
        )

        if idempotent_mutation is not None:
            response = resemble.cloud.v1alpha1.application.application_pb2.UpResponse()
            response.ParseFromString(idempotent_mutation.response)
            return response

        async with self._state_manager.transactionally(
            context, self.tasks_dispatcher
        ) as transaction:
            if transaction is not None:
                context.participants.add(
                    self._servicer.__service_name__, context.actor_id
                )
            # TODO: this loads a `state` object even when we know we're calling a constructor,
            # in which case (by definition) there is no state. Can we (and is it worth
            # the effort to) change this call to avoid that overhead in that case?
            async with self._state_manager.writer(
                context,
                self._servicer.__state_type__,
                transaction=transaction,
                from_constructor=False,
                requires_constructor=True
            ) as (state, writer):

                await self._maybe_authorize(
                    method_name=
                    'resemble.cloud.v1alpha1.application.Application.Up',
                    headers=context._headers,
                    auth=context.auth,
                    state=state,
                    request=request,
                )

                effects = await self.__Up(
                    context,
                    state,
                    request,
                    validating_effects=validating_effects,
                )

                if effects.tasks is not None:
                    # NOTE: we validate tasks added as part of a
                    # transaction when we prepare.
                    if transaction is None:
                        await self.tasks_dispatcher.validate(
                            effects.tasks
                        )

                await writer.complete(effects)

                if effects.tasks is not None:
                    if transaction is None:
                        self.tasks_dispatcher.dispatch(effects.tasks)
                    else:
                        assert all(
                            task.task_id.state_type == transaction.state_type
                            for task in effects.tasks
                        ), 'Task state type does not match transaction state type'
                        transaction.tasks.extend(effects.tasks)

                # TODO: We need a single `Effects` superclass for all methods, so we
                # would need to make it "partially" generic (with per-method subclasses
                # filling out the rest of the generic parameters) in order to fix this.
                return effects.response  # type: ignore[return-value]

    async def _schedule_Up(
        self,
        *,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        headers: Headers,
        grpc_context: grpc.aio.ServicerContext,
    ) -> tuple[WriterContext, resemble.cloud.v1alpha1.application.application_pb2.UpResponse]:
        context: WriterContext = self.create_context(
            headers=headers,
            context_type=WriterContext,
        )
        response = resemble.cloud.v1alpha1.application.application_pb2.UpResponse()

        # Check if we already have performed this mutation!
        #
        # We do this _before_ calling 'transactionally()' because
        # if this call is for a transaction method _and_ we've
        # already performed the transaction then we don't want to
        # become a transaction participant (again) we just want to
        # return the transaction's response.
        idempotent_mutation = self._state_manager.check_for_idempotent_mutation(
            context
        )

        if idempotent_mutation is not None:
            response.ParseFromString(idempotent_mutation.response)

            # We should have only scheduled a single task!
            assert len(idempotent_mutation.task_ids) == 1
            assert grpc_context is not None
            grpc_context.set_trailing_metadata(
                grpc_context.trailing_metadata() +
                (
                    (
                        resemble.aio.headers.TASK_ID_UUID,
                        str(uuid.UUID(bytes=idempotent_mutation.task_ids[0].task_uuid))
                    ),
                )
            )

            return context, response

        async with self._state_manager.transactionally(
            context, self.tasks_dispatcher
        ) as transaction:
            if transaction is not None:
                context.participants.add(
                    self._servicer.__service_name__, context.actor_id
                )
            async with self._state_manager.writer(
                context,
                self._servicer.__state_type__,
                transaction=transaction,
                from_constructor=False,
                requires_constructor=True
            ) as (state, writer):

                # Try to verify the token if a token verifier exists.
                context.auth = await self._maybe_verify_token(headers)

                # Check if we are allowed schedule the task.
                await self._maybe_authorize(
                    method_name=
                    'resemble.cloud.v1alpha1.application.Application.Up',
                    headers=context._headers,
                    auth=context.auth,
                    state=state,
                    request=request,
                )

                task = ApplicationServicerTasksStub(
                    context=context,
                    actor_id=context.actor_id,
                ).Up(
                    request,
                    schedule=context._headers.task_schedule,
                )

                effects = Effects(
                    response=response,
                    state=state,
                    tasks=[task],
                )

                assert effects.tasks is not None

                # NOTE: we validate tasks added as part of a
                # transaction when we prepare.
                if transaction is None:
                    await self.tasks_dispatcher.validate(effects.tasks)

                await writer.complete(effects)

                if transaction is None:
                    self.tasks_dispatcher.dispatch(effects.tasks)
                else:
                    assert task.task_id.state_type == transaction.state_type
                    transaction.tasks.extend(effects.tasks)

                assert grpc_context is not None

                grpc_context.set_trailing_metadata(
                    grpc_context.trailing_metadata() +
                    (
                        (
                            resemble.aio.headers.TASK_ID_UUID,
                            str(uuid.UUID(bytes=task.task_id.task_uuid))
                        ),
                    )
                )

                return context, response

        return context, response


    @maybe_run_method_twice_to_validate_effects
    async def Up(
        self,
        validating_effects: bool,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        grpc_context: grpc.aio.ServicerContext,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.UpResponse:
        context: Optional[Context] = None
        try:
            headers = Headers.from_grpc_context(grpc_context)
            if headers.task_schedule is not None:
                context, response = await self._schedule_Up(
                    headers=headers,
                    request=request,
                    grpc_context=grpc_context,
                )
                return response

            context = self.create_context(
                headers=headers,
                context_type=WriterContext,
            )
            assert context is not None

            return await self._Up(
                request,
                context,
                validating_effects=validating_effects,
                grpc_context=grpc_context,
            )
        except EffectValidationRetry:
            # Doing effect validation, just let this propagate.
            raise
        except resemble.aio.aborted.Aborted as aborted:
            await grpc_context.abort_with_status(
                rpc_status.to_status(aborted.to_status())
            )
            raise  # Unreachable but necessary for mypy.
        except asyncio.CancelledError:
            # It's pretty normal for an RPC to be cancelled; it's not useful to
            # print a stack trace.
            raise
        except:
            # Print the exception stack trace for easier debugging. Note
            # that we don't include the stack trace in an error message
            # for the same reason that gRPC doesn't do so by default,
            # see https://github.com/grpc/grpc/issues/14897, but since this
            # should only get logged on the server side it is safe.
            logger.warning(
                'Unhandled exception\n' +
                ''.join(traceback.format_exc())
            )

            # Re-raise the exception for gRPC to handle!
            raise
        finally:
            if context is not None and context.transaction_id is not None:
                # Propagate transaction participants.
                grpc_context.set_trailing_metadata(
                    grpc_context.trailing_metadata() +
                    context.participants.to_grpc_metadata()
                )

    async def __UpTask(
        self,
        context: WriterContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        *,
        validating_effects: bool,
    ) -> Application.UpTaskEffects:
        try:
            response = (
                await self._servicer.UpTask(
                    context=context,
                    state=state,
                    request=request
                )
            )
            self.maybe_raise_effect_validation_retry(
                logger=logger,
                idempotency_manager=context,
                method_name='Application.UpTask',
                validating_effects=validating_effects,
                context=context,
            )
            return response
        except resemble.aio.contexts.RetryReactively:
            # Retrying reactively, just let this propagate.
            raise
        except EffectValidationRetry:
            # Doing effect validation, just let this propagate.
            raise
        except resemble.aio.aborted.Aborted as aborted:
            # Log any _unhandled_ abort stack traces to make it
            # easier for debugging.
            #
            # NOTE: we don't log if we're a task as it will be logged
            # in `resemble/aio/internals/tasks_dispatcher.py` instead.
            aborted_type: Optional[type] = None
            aborted_type = Application.UpTaskAborted
            if isinstance(aborted, resemble.aio.aborted.SystemAborted):
                if context.task is None:
                    logger.warning(
                        f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.UpTask') {aborted}; propagating as 'Unknown'\n" +
                        ''.join(traceback.format_exception(aborted))
                    )
                raise resemble.aio.aborted.SystemAborted(
                    resemble.v1alpha1.errors_pb2.Unknown(),
                    # TODO(benh): consider whether or not we want to
                    # include the 'package.service.method' which may
                    # get concatenated together forming a kind of
                    # "stack trace"; while it's super helpful for
                    # debugging, it does expose implementation
                    # information.
                    message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.UpTask') {aborted}"
                )
            else:
                if (
                    aborted_type is not None and
                    not isinstance(aborted, aborted_type) and
                    aborted_type.is_declared_error(aborted.error)
                ):
                    if context.task is None:
                        logger.warning(
                            f"Propagating unhandled (in 'resemble.cloud.v1alpha1.application.Application.UpTask') {aborted}"
                        )
                elif (
                    aborted_type is None or
                    not isinstance(aborted, aborted_type)
                ):
                    if context.task is None:
                        logger.warning(
                            f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.UpTask') {aborted}; propagating as 'Unknown'\n" +
                            ''.join(traceback.format_exception(aborted))
                        )
                    raise resemble.aio.aborted.SystemAborted(
                        resemble.v1alpha1.errors_pb2.Unknown(),
                        # TODO(benh): consider whether or not we want to
                        # include the 'package.service.method' which may
                        # get concatenated together forming a kind of
                        # "stack trace"; while it's super helpful for
                        # debugging, it does expose implementation
                        # information.
                        message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.UpTask') {aborted}"
                    )

            raise
        except asyncio.CancelledError:
            # It's pretty normal for an RPC to be cancelled; it's not useful to
            # print a stack trace.
            raise
        except BaseException as exception:
            if context.task is None:
                logger.warning(
                    f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.UpTask') {type(exception).__name__}: {exception}; propagating as 'Unknown'\n" +
                    ''.join(traceback.format_exception(exception))
                )
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.Unknown(),
                # TODO(benh): consider whether or not we want to
                # include the 'package.service.method' which may
                # get concatenated together forming a kind of
                # "stack trace"; while it's super helpful for
                # debugging, it does expose implementation
                # information.
                message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.UpTask') {type(exception).__name__}: {exception}"
            )

    async def _UpTask(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        context: WriterContext,
        *,
        validating_effects: bool,
        grpc_context: Optional[grpc.aio.ServicerContext] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse:
        # Try to verify the token if a token verifier exists.
        context.auth = await self._maybe_verify_token(context._headers)

        # Check if we already have performed this mutation!
        #
        # We do this _before_ calling 'transactionally()' because
        # if this call is for a transaction method _and_ we've
        # already performed the transaction then we don't want to
        # become a transaction participant (again) we just want to
        # return the transaction's response.
        idempotent_mutation = self._state_manager.check_for_idempotent_mutation(
            context
        )

        if idempotent_mutation is not None:
            response = resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse()
            response.ParseFromString(idempotent_mutation.response)
            return response

        async with self._state_manager.transactionally(
            context, self.tasks_dispatcher
        ) as transaction:
            if transaction is not None:
                context.participants.add(
                    self._servicer.__service_name__, context.actor_id
                )
            # TODO: this loads a `state` object even when we know we're calling a constructor,
            # in which case (by definition) there is no state. Can we (and is it worth
            # the effort to) change this call to avoid that overhead in that case?
            async with self._state_manager.writer(
                context,
                self._servicer.__state_type__,
                transaction=transaction,
                from_constructor=False,
                requires_constructor=True
            ) as (state, writer):

                await self._maybe_authorize(
                    method_name=
                    'resemble.cloud.v1alpha1.application.Application.UpTask',
                    headers=context._headers,
                    auth=context.auth,
                    state=state,
                    request=request,
                )

                effects = await self.__UpTask(
                    context,
                    state,
                    request,
                    validating_effects=validating_effects,
                )

                if effects.tasks is not None:
                    # NOTE: we validate tasks added as part of a
                    # transaction when we prepare.
                    if transaction is None:
                        await self.tasks_dispatcher.validate(
                            effects.tasks
                        )

                await writer.complete(effects)

                if effects.tasks is not None:
                    if transaction is None:
                        self.tasks_dispatcher.dispatch(effects.tasks)
                    else:
                        assert all(
                            task.task_id.state_type == transaction.state_type
                            for task in effects.tasks
                        ), 'Task state type does not match transaction state type'
                        transaction.tasks.extend(effects.tasks)

                # TODO: We need a single `Effects` superclass for all methods, so we
                # would need to make it "partially" generic (with per-method subclasses
                # filling out the rest of the generic parameters) in order to fix this.
                return effects.response  # type: ignore[return-value]

    async def _schedule_UpTask(
        self,
        *,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        headers: Headers,
        grpc_context: grpc.aio.ServicerContext,
    ) -> tuple[WriterContext, resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse]:
        context: WriterContext = self.create_context(
            headers=headers,
            context_type=WriterContext,
        )
        response = resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse()

        # Check if we already have performed this mutation!
        #
        # We do this _before_ calling 'transactionally()' because
        # if this call is for a transaction method _and_ we've
        # already performed the transaction then we don't want to
        # become a transaction participant (again) we just want to
        # return the transaction's response.
        idempotent_mutation = self._state_manager.check_for_idempotent_mutation(
            context
        )

        if idempotent_mutation is not None:
            response.ParseFromString(idempotent_mutation.response)

            # We should have only scheduled a single task!
            assert len(idempotent_mutation.task_ids) == 1
            assert grpc_context is not None
            grpc_context.set_trailing_metadata(
                grpc_context.trailing_metadata() +
                (
                    (
                        resemble.aio.headers.TASK_ID_UUID,
                        str(uuid.UUID(bytes=idempotent_mutation.task_ids[0].task_uuid))
                    ),
                )
            )

            return context, response

        async with self._state_manager.transactionally(
            context, self.tasks_dispatcher
        ) as transaction:
            if transaction is not None:
                context.participants.add(
                    self._servicer.__service_name__, context.actor_id
                )
            async with self._state_manager.writer(
                context,
                self._servicer.__state_type__,
                transaction=transaction,
                from_constructor=False,
                requires_constructor=True
            ) as (state, writer):

                # Try to verify the token if a token verifier exists.
                context.auth = await self._maybe_verify_token(headers)

                # Check if we are allowed schedule the task.
                await self._maybe_authorize(
                    method_name=
                    'resemble.cloud.v1alpha1.application.Application.UpTask',
                    headers=context._headers,
                    auth=context.auth,
                    state=state,
                    request=request,
                )

                task = ApplicationServicerTasksStub(
                    context=context,
                    actor_id=context.actor_id,
                ).UpTask(
                    request,
                    schedule=context._headers.task_schedule,
                )

                effects = Effects(
                    response=response,
                    state=state,
                    tasks=[task],
                )

                assert effects.tasks is not None

                # NOTE: we validate tasks added as part of a
                # transaction when we prepare.
                if transaction is None:
                    await self.tasks_dispatcher.validate(effects.tasks)

                await writer.complete(effects)

                if transaction is None:
                    self.tasks_dispatcher.dispatch(effects.tasks)
                else:
                    assert task.task_id.state_type == transaction.state_type
                    transaction.tasks.extend(effects.tasks)

                assert grpc_context is not None

                grpc_context.set_trailing_metadata(
                    grpc_context.trailing_metadata() +
                    (
                        (
                            resemble.aio.headers.TASK_ID_UUID,
                            str(uuid.UUID(bytes=task.task_id.task_uuid))
                        ),
                    )
                )

                return context, response

        return context, response


    @maybe_run_method_twice_to_validate_effects
    async def UpTask(
        self,
        validating_effects: bool,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        grpc_context: grpc.aio.ServicerContext,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse:
        context: Optional[Context] = None
        try:
            headers = Headers.from_grpc_context(grpc_context)
            if headers.task_schedule is not None:
                context, response = await self._schedule_UpTask(
                    headers=headers,
                    request=request,
                    grpc_context=grpc_context,
                )
                return response

            context = self.create_context(
                headers=headers,
                context_type=WriterContext,
            )
            assert context is not None

            return await self._UpTask(
                request,
                context,
                validating_effects=validating_effects,
                grpc_context=grpc_context,
            )
        except EffectValidationRetry:
            # Doing effect validation, just let this propagate.
            raise
        except resemble.aio.aborted.Aborted as aborted:
            await grpc_context.abort_with_status(
                rpc_status.to_status(aborted.to_status())
            )
            raise  # Unreachable but necessary for mypy.
        except asyncio.CancelledError:
            # It's pretty normal for an RPC to be cancelled; it's not useful to
            # print a stack trace.
            raise
        except:
            # Print the exception stack trace for easier debugging. Note
            # that we don't include the stack trace in an error message
            # for the same reason that gRPC doesn't do so by default,
            # see https://github.com/grpc/grpc/issues/14897, but since this
            # should only get logged on the server side it is safe.
            logger.warning(
                'Unhandled exception\n' +
                ''.join(traceback.format_exc())
            )

            # Re-raise the exception for gRPC to handle!
            raise
        finally:
            if context is not None and context.transaction_id is not None:
                # Propagate transaction participants.
                grpc_context.set_trailing_metadata(
                    grpc_context.trailing_metadata() +
                    context.participants.to_grpc_metadata()
                )

    async def __Down(
        self,
        context: WriterContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownRequest,
        *,
        validating_effects: bool,
    ) -> Application.DownEffects:
        try:
            response = (
                await self._servicer.Down(
                    context=context,
                    state=state,
                    request=request
                )
            )
            self.maybe_raise_effect_validation_retry(
                logger=logger,
                idempotency_manager=context,
                method_name='Application.Down',
                validating_effects=validating_effects,
                context=context,
            )
            return response
        except resemble.aio.contexts.RetryReactively:
            # Retrying reactively, just let this propagate.
            raise
        except EffectValidationRetry:
            # Doing effect validation, just let this propagate.
            raise
        except resemble.aio.aborted.Aborted as aborted:
            # Log any _unhandled_ abort stack traces to make it
            # easier for debugging.
            #
            # NOTE: we don't log if we're a task as it will be logged
            # in `resemble/aio/internals/tasks_dispatcher.py` instead.
            aborted_type: Optional[type] = None
            aborted_type = Application.DownAborted
            if isinstance(aborted, resemble.aio.aborted.SystemAborted):
                if context.task is None:
                    logger.warning(
                        f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.Down') {aborted}; propagating as 'Unknown'\n" +
                        ''.join(traceback.format_exception(aborted))
                    )
                raise resemble.aio.aborted.SystemAborted(
                    resemble.v1alpha1.errors_pb2.Unknown(),
                    # TODO(benh): consider whether or not we want to
                    # include the 'package.service.method' which may
                    # get concatenated together forming a kind of
                    # "stack trace"; while it's super helpful for
                    # debugging, it does expose implementation
                    # information.
                    message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.Down') {aborted}"
                )
            else:
                if (
                    aborted_type is not None and
                    not isinstance(aborted, aborted_type) and
                    aborted_type.is_declared_error(aborted.error)
                ):
                    if context.task is None:
                        logger.warning(
                            f"Propagating unhandled (in 'resemble.cloud.v1alpha1.application.Application.Down') {aborted}"
                        )
                elif (
                    aborted_type is None or
                    not isinstance(aborted, aborted_type)
                ):
                    if context.task is None:
                        logger.warning(
                            f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.Down') {aborted}; propagating as 'Unknown'\n" +
                            ''.join(traceback.format_exception(aborted))
                        )
                    raise resemble.aio.aborted.SystemAborted(
                        resemble.v1alpha1.errors_pb2.Unknown(),
                        # TODO(benh): consider whether or not we want to
                        # include the 'package.service.method' which may
                        # get concatenated together forming a kind of
                        # "stack trace"; while it's super helpful for
                        # debugging, it does expose implementation
                        # information.
                        message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.Down') {aborted}"
                    )

            raise
        except asyncio.CancelledError:
            # It's pretty normal for an RPC to be cancelled; it's not useful to
            # print a stack trace.
            raise
        except BaseException as exception:
            if context.task is None:
                logger.warning(
                    f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.Down') {type(exception).__name__}: {exception}; propagating as 'Unknown'\n" +
                    ''.join(traceback.format_exception(exception))
                )
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.Unknown(),
                # TODO(benh): consider whether or not we want to
                # include the 'package.service.method' which may
                # get concatenated together forming a kind of
                # "stack trace"; while it's super helpful for
                # debugging, it does expose implementation
                # information.
                message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.Down') {type(exception).__name__}: {exception}"
            )

    async def _Down(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownRequest,
        context: WriterContext,
        *,
        validating_effects: bool,
        grpc_context: Optional[grpc.aio.ServicerContext] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.DownResponse:
        # Try to verify the token if a token verifier exists.
        context.auth = await self._maybe_verify_token(context._headers)

        # Check if we already have performed this mutation!
        #
        # We do this _before_ calling 'transactionally()' because
        # if this call is for a transaction method _and_ we've
        # already performed the transaction then we don't want to
        # become a transaction participant (again) we just want to
        # return the transaction's response.
        idempotent_mutation = self._state_manager.check_for_idempotent_mutation(
            context
        )

        if idempotent_mutation is not None:
            response = resemble.cloud.v1alpha1.application.application_pb2.DownResponse()
            response.ParseFromString(idempotent_mutation.response)
            return response

        async with self._state_manager.transactionally(
            context, self.tasks_dispatcher
        ) as transaction:
            if transaction is not None:
                context.participants.add(
                    self._servicer.__service_name__, context.actor_id
                )
            # TODO: this loads a `state` object even when we know we're calling a constructor,
            # in which case (by definition) there is no state. Can we (and is it worth
            # the effort to) change this call to avoid that overhead in that case?
            async with self._state_manager.writer(
                context,
                self._servicer.__state_type__,
                transaction=transaction,
                from_constructor=False,
                requires_constructor=True
            ) as (state, writer):

                await self._maybe_authorize(
                    method_name=
                    'resemble.cloud.v1alpha1.application.Application.Down',
                    headers=context._headers,
                    auth=context.auth,
                    state=state,
                    request=request,
                )

                effects = await self.__Down(
                    context,
                    state,
                    request,
                    validating_effects=validating_effects,
                )

                if effects.tasks is not None:
                    # NOTE: we validate tasks added as part of a
                    # transaction when we prepare.
                    if transaction is None:
                        await self.tasks_dispatcher.validate(
                            effects.tasks
                        )

                await writer.complete(effects)

                if effects.tasks is not None:
                    if transaction is None:
                        self.tasks_dispatcher.dispatch(effects.tasks)
                    else:
                        assert all(
                            task.task_id.state_type == transaction.state_type
                            for task in effects.tasks
                        ), 'Task state type does not match transaction state type'
                        transaction.tasks.extend(effects.tasks)

                # TODO: We need a single `Effects` superclass for all methods, so we
                # would need to make it "partially" generic (with per-method subclasses
                # filling out the rest of the generic parameters) in order to fix this.
                return effects.response  # type: ignore[return-value]

    async def _schedule_Down(
        self,
        *,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownRequest,
        headers: Headers,
        grpc_context: grpc.aio.ServicerContext,
    ) -> tuple[WriterContext, resemble.cloud.v1alpha1.application.application_pb2.DownResponse]:
        context: WriterContext = self.create_context(
            headers=headers,
            context_type=WriterContext,
        )
        response = resemble.cloud.v1alpha1.application.application_pb2.DownResponse()

        # Check if we already have performed this mutation!
        #
        # We do this _before_ calling 'transactionally()' because
        # if this call is for a transaction method _and_ we've
        # already performed the transaction then we don't want to
        # become a transaction participant (again) we just want to
        # return the transaction's response.
        idempotent_mutation = self._state_manager.check_for_idempotent_mutation(
            context
        )

        if idempotent_mutation is not None:
            response.ParseFromString(idempotent_mutation.response)

            # We should have only scheduled a single task!
            assert len(idempotent_mutation.task_ids) == 1
            assert grpc_context is not None
            grpc_context.set_trailing_metadata(
                grpc_context.trailing_metadata() +
                (
                    (
                        resemble.aio.headers.TASK_ID_UUID,
                        str(uuid.UUID(bytes=idempotent_mutation.task_ids[0].task_uuid))
                    ),
                )
            )

            return context, response

        async with self._state_manager.transactionally(
            context, self.tasks_dispatcher
        ) as transaction:
            if transaction is not None:
                context.participants.add(
                    self._servicer.__service_name__, context.actor_id
                )
            async with self._state_manager.writer(
                context,
                self._servicer.__state_type__,
                transaction=transaction,
                from_constructor=False,
                requires_constructor=True
            ) as (state, writer):

                # Try to verify the token if a token verifier exists.
                context.auth = await self._maybe_verify_token(headers)

                # Check if we are allowed schedule the task.
                await self._maybe_authorize(
                    method_name=
                    'resemble.cloud.v1alpha1.application.Application.Down',
                    headers=context._headers,
                    auth=context.auth,
                    state=state,
                    request=request,
                )

                task = ApplicationServicerTasksStub(
                    context=context,
                    actor_id=context.actor_id,
                ).Down(
                    request,
                    schedule=context._headers.task_schedule,
                )

                effects = Effects(
                    response=response,
                    state=state,
                    tasks=[task],
                )

                assert effects.tasks is not None

                # NOTE: we validate tasks added as part of a
                # transaction when we prepare.
                if transaction is None:
                    await self.tasks_dispatcher.validate(effects.tasks)

                await writer.complete(effects)

                if transaction is None:
                    self.tasks_dispatcher.dispatch(effects.tasks)
                else:
                    assert task.task_id.state_type == transaction.state_type
                    transaction.tasks.extend(effects.tasks)

                assert grpc_context is not None

                grpc_context.set_trailing_metadata(
                    grpc_context.trailing_metadata() +
                    (
                        (
                            resemble.aio.headers.TASK_ID_UUID,
                            str(uuid.UUID(bytes=task.task_id.task_uuid))
                        ),
                    )
                )

                return context, response

        return context, response


    @maybe_run_method_twice_to_validate_effects
    async def Down(
        self,
        validating_effects: bool,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownRequest,
        grpc_context: grpc.aio.ServicerContext,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.DownResponse:
        context: Optional[Context] = None
        try:
            headers = Headers.from_grpc_context(grpc_context)
            if headers.task_schedule is not None:
                context, response = await self._schedule_Down(
                    headers=headers,
                    request=request,
                    grpc_context=grpc_context,
                )
                return response

            context = self.create_context(
                headers=headers,
                context_type=WriterContext,
            )
            assert context is not None

            return await self._Down(
                request,
                context,
                validating_effects=validating_effects,
                grpc_context=grpc_context,
            )
        except EffectValidationRetry:
            # Doing effect validation, just let this propagate.
            raise
        except resemble.aio.aborted.Aborted as aborted:
            await grpc_context.abort_with_status(
                rpc_status.to_status(aborted.to_status())
            )
            raise  # Unreachable but necessary for mypy.
        except asyncio.CancelledError:
            # It's pretty normal for an RPC to be cancelled; it's not useful to
            # print a stack trace.
            raise
        except:
            # Print the exception stack trace for easier debugging. Note
            # that we don't include the stack trace in an error message
            # for the same reason that gRPC doesn't do so by default,
            # see https://github.com/grpc/grpc/issues/14897, but since this
            # should only get logged on the server side it is safe.
            logger.warning(
                'Unhandled exception\n' +
                ''.join(traceback.format_exc())
            )

            # Re-raise the exception for gRPC to handle!
            raise
        finally:
            if context is not None and context.transaction_id is not None:
                # Propagate transaction participants.
                grpc_context.set_trailing_metadata(
                    grpc_context.trailing_metadata() +
                    context.participants.to_grpc_metadata()
                )

    async def __DownTask(
        self,
        context: WriterContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest,
        *,
        validating_effects: bool,
    ) -> Application.DownTaskEffects:
        try:
            response = (
                await self._servicer.DownTask(
                    context=context,
                    state=state,
                    request=request
                )
            )
            self.maybe_raise_effect_validation_retry(
                logger=logger,
                idempotency_manager=context,
                method_name='Application.DownTask',
                validating_effects=validating_effects,
                context=context,
            )
            return response
        except resemble.aio.contexts.RetryReactively:
            # Retrying reactively, just let this propagate.
            raise
        except EffectValidationRetry:
            # Doing effect validation, just let this propagate.
            raise
        except resemble.aio.aborted.Aborted as aborted:
            # Log any _unhandled_ abort stack traces to make it
            # easier for debugging.
            #
            # NOTE: we don't log if we're a task as it will be logged
            # in `resemble/aio/internals/tasks_dispatcher.py` instead.
            aborted_type: Optional[type] = None
            aborted_type = Application.DownTaskAborted
            if isinstance(aborted, resemble.aio.aborted.SystemAborted):
                if context.task is None:
                    logger.warning(
                        f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.DownTask') {aborted}; propagating as 'Unknown'\n" +
                        ''.join(traceback.format_exception(aborted))
                    )
                raise resemble.aio.aborted.SystemAborted(
                    resemble.v1alpha1.errors_pb2.Unknown(),
                    # TODO(benh): consider whether or not we want to
                    # include the 'package.service.method' which may
                    # get concatenated together forming a kind of
                    # "stack trace"; while it's super helpful for
                    # debugging, it does expose implementation
                    # information.
                    message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.DownTask') {aborted}"
                )
            else:
                if (
                    aborted_type is not None and
                    not isinstance(aborted, aborted_type) and
                    aborted_type.is_declared_error(aborted.error)
                ):
                    if context.task is None:
                        logger.warning(
                            f"Propagating unhandled (in 'resemble.cloud.v1alpha1.application.Application.DownTask') {aborted}"
                        )
                elif (
                    aborted_type is None or
                    not isinstance(aborted, aborted_type)
                ):
                    if context.task is None:
                        logger.warning(
                            f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.DownTask') {aborted}; propagating as 'Unknown'\n" +
                            ''.join(traceback.format_exception(aborted))
                        )
                    raise resemble.aio.aborted.SystemAborted(
                        resemble.v1alpha1.errors_pb2.Unknown(),
                        # TODO(benh): consider whether or not we want to
                        # include the 'package.service.method' which may
                        # get concatenated together forming a kind of
                        # "stack trace"; while it's super helpful for
                        # debugging, it does expose implementation
                        # information.
                        message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.DownTask') {aborted}"
                    )

            raise
        except asyncio.CancelledError:
            # It's pretty normal for an RPC to be cancelled; it's not useful to
            # print a stack trace.
            raise
        except BaseException as exception:
            if context.task is None:
                logger.warning(
                    f"Unhandled (in 'resemble.cloud.v1alpha1.application.Application.DownTask') {type(exception).__name__}: {exception}; propagating as 'Unknown'\n" +
                    ''.join(traceback.format_exception(exception))
                )
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.Unknown(),
                # TODO(benh): consider whether or not we want to
                # include the 'package.service.method' which may
                # get concatenated together forming a kind of
                # "stack trace"; while it's super helpful for
                # debugging, it does expose implementation
                # information.
                message=f"unhandled (in 'resemble.cloud.v1alpha1.application.Application.DownTask') {type(exception).__name__}: {exception}"
            )

    async def _DownTask(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest,
        context: WriterContext,
        *,
        validating_effects: bool,
        grpc_context: Optional[grpc.aio.ServicerContext] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse:
        # Try to verify the token if a token verifier exists.
        context.auth = await self._maybe_verify_token(context._headers)

        # Check if we already have performed this mutation!
        #
        # We do this _before_ calling 'transactionally()' because
        # if this call is for a transaction method _and_ we've
        # already performed the transaction then we don't want to
        # become a transaction participant (again) we just want to
        # return the transaction's response.
        idempotent_mutation = self._state_manager.check_for_idempotent_mutation(
            context
        )

        if idempotent_mutation is not None:
            response = resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse()
            response.ParseFromString(idempotent_mutation.response)
            return response

        async with self._state_manager.transactionally(
            context, self.tasks_dispatcher
        ) as transaction:
            if transaction is not None:
                context.participants.add(
                    self._servicer.__service_name__, context.actor_id
                )
            # TODO: this loads a `state` object even when we know we're calling a constructor,
            # in which case (by definition) there is no state. Can we (and is it worth
            # the effort to) change this call to avoid that overhead in that case?
            async with self._state_manager.writer(
                context,
                self._servicer.__state_type__,
                transaction=transaction,
                from_constructor=False,
                requires_constructor=True
            ) as (state, writer):

                await self._maybe_authorize(
                    method_name=
                    'resemble.cloud.v1alpha1.application.Application.DownTask',
                    headers=context._headers,
                    auth=context.auth,
                    state=state,
                    request=request,
                )

                effects = await self.__DownTask(
                    context,
                    state,
                    request,
                    validating_effects=validating_effects,
                )

                if effects.tasks is not None:
                    # NOTE: we validate tasks added as part of a
                    # transaction when we prepare.
                    if transaction is None:
                        await self.tasks_dispatcher.validate(
                            effects.tasks
                        )

                await writer.complete(effects)

                if effects.tasks is not None:
                    if transaction is None:
                        self.tasks_dispatcher.dispatch(effects.tasks)
                    else:
                        assert all(
                            task.task_id.state_type == transaction.state_type
                            for task in effects.tasks
                        ), 'Task state type does not match transaction state type'
                        transaction.tasks.extend(effects.tasks)

                # TODO: We need a single `Effects` superclass for all methods, so we
                # would need to make it "partially" generic (with per-method subclasses
                # filling out the rest of the generic parameters) in order to fix this.
                return effects.response  # type: ignore[return-value]

    async def _schedule_DownTask(
        self,
        *,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest,
        headers: Headers,
        grpc_context: grpc.aio.ServicerContext,
    ) -> tuple[WriterContext, resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse]:
        context: WriterContext = self.create_context(
            headers=headers,
            context_type=WriterContext,
        )
        response = resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse()

        # Check if we already have performed this mutation!
        #
        # We do this _before_ calling 'transactionally()' because
        # if this call is for a transaction method _and_ we've
        # already performed the transaction then we don't want to
        # become a transaction participant (again) we just want to
        # return the transaction's response.
        idempotent_mutation = self._state_manager.check_for_idempotent_mutation(
            context
        )

        if idempotent_mutation is not None:
            response.ParseFromString(idempotent_mutation.response)

            # We should have only scheduled a single task!
            assert len(idempotent_mutation.task_ids) == 1
            assert grpc_context is not None
            grpc_context.set_trailing_metadata(
                grpc_context.trailing_metadata() +
                (
                    (
                        resemble.aio.headers.TASK_ID_UUID,
                        str(uuid.UUID(bytes=idempotent_mutation.task_ids[0].task_uuid))
                    ),
                )
            )

            return context, response

        async with self._state_manager.transactionally(
            context, self.tasks_dispatcher
        ) as transaction:
            if transaction is not None:
                context.participants.add(
                    self._servicer.__service_name__, context.actor_id
                )
            async with self._state_manager.writer(
                context,
                self._servicer.__state_type__,
                transaction=transaction,
                from_constructor=False,
                requires_constructor=True
            ) as (state, writer):

                # Try to verify the token if a token verifier exists.
                context.auth = await self._maybe_verify_token(headers)

                # Check if we are allowed schedule the task.
                await self._maybe_authorize(
                    method_name=
                    'resemble.cloud.v1alpha1.application.Application.DownTask',
                    headers=context._headers,
                    auth=context.auth,
                    state=state,
                    request=request,
                )

                task = ApplicationServicerTasksStub(
                    context=context,
                    actor_id=context.actor_id,
                ).DownTask(
                    request,
                    schedule=context._headers.task_schedule,
                )

                effects = Effects(
                    response=response,
                    state=state,
                    tasks=[task],
                )

                assert effects.tasks is not None

                # NOTE: we validate tasks added as part of a
                # transaction when we prepare.
                if transaction is None:
                    await self.tasks_dispatcher.validate(effects.tasks)

                await writer.complete(effects)

                if transaction is None:
                    self.tasks_dispatcher.dispatch(effects.tasks)
                else:
                    assert task.task_id.state_type == transaction.state_type
                    transaction.tasks.extend(effects.tasks)

                assert grpc_context is not None

                grpc_context.set_trailing_metadata(
                    grpc_context.trailing_metadata() +
                    (
                        (
                            resemble.aio.headers.TASK_ID_UUID,
                            str(uuid.UUID(bytes=task.task_id.task_uuid))
                        ),
                    )
                )

                return context, response

        return context, response


    @maybe_run_method_twice_to_validate_effects
    async def DownTask(
        self,
        validating_effects: bool,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest,
        grpc_context: grpc.aio.ServicerContext,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse:
        context: Optional[Context] = None
        try:
            headers = Headers.from_grpc_context(grpc_context)
            if headers.task_schedule is not None:
                context, response = await self._schedule_DownTask(
                    headers=headers,
                    request=request,
                    grpc_context=grpc_context,
                )
                return response

            context = self.create_context(
                headers=headers,
                context_type=WriterContext,
            )
            assert context is not None

            return await self._DownTask(
                request,
                context,
                validating_effects=validating_effects,
                grpc_context=grpc_context,
            )
        except EffectValidationRetry:
            # Doing effect validation, just let this propagate.
            raise
        except resemble.aio.aborted.Aborted as aborted:
            await grpc_context.abort_with_status(
                rpc_status.to_status(aborted.to_status())
            )
            raise  # Unreachable but necessary for mypy.
        except asyncio.CancelledError:
            # It's pretty normal for an RPC to be cancelled; it's not useful to
            # print a stack trace.
            raise
        except:
            # Print the exception stack trace for easier debugging. Note
            # that we don't include the stack trace in an error message
            # for the same reason that gRPC doesn't do so by default,
            # see https://github.com/grpc/grpc/issues/14897, but since this
            # should only get logged on the server side it is safe.
            logger.warning(
                'Unhandled exception\n' +
                ''.join(traceback.format_exc())
            )

            # Re-raise the exception for gRPC to handle!
            raise
        finally:
            if context is not None and context.transaction_id is not None:
                # Propagate transaction participants.
                grpc_context.set_trailing_metadata(
                    grpc_context.trailing_metadata() +
                    context.participants.to_grpc_metadata()
                )

    async def _maybe_authorize(
        self,
        *,
        method_name: str,
        headers: Headers,
        auth: Optional[resemble.aio.auth.Auth],
        state: Optional[ApplicationStateType] = None,
        request: Optional[ApplicationRequestTypes] = None,
    ) -> None:
        """Check authorization decision for the given method, using available
        information.

        Raises `PermissionDenied` in case authorizer is present but the request
        is not authorized.
        """
        # To authorize internal calls, we use an internal magic token.
        if headers.bearer_token == __internal_magic_token__:
            return

        if self._authorizer is None:
            return

        if not self._authorizer.can_authorize(method_name):
            # Better safe than sorry.
            raise resemble.aio.aborted.SystemAborted(
                resemble.v1alpha1.errors_pb2.PermissionDenied(),
                message=
                    f"Authorizer does not support method '{method_name}'"
            )

        # If there is state, ensure that we don't accidentally mutate it.
        if state is not None:
            # TODO: If we can read-only a state object we can avoid a copy here.
            state_copy = ApplicationStateType()
            state_copy.CopyFrom(state)
            state = state_copy

        # Create context for the authorizer. This is a `ReaderContext`
        # independently of the calling context.
        with self.use_context(
            headers=(
                # Get headers suitable for doing authorization.
                headers.copy_for_token_verification_and_authorization()
            ),
            context_type=ReaderContext,
        ) as context:
            context.auth = auth

            # Get the authorizer decision.
            authorization_decision = await self._authorizer.authorize(
                method_name=method_name,
                context=context,
                state=state,
                request=request,
            )

        # Enforce correct authorizer decision type.
        try:
            assert_type(
                authorization_decision,
                [
                    resemble.v1alpha1.errors_pb2.Ok,
                    resemble.v1alpha1.errors_pb2.Unauthenticated,
                    resemble.v1alpha1.errors_pb2.PermissionDenied,
                ]
            )
        except TypeError as e:
            # Recast the exception to provide more context.
            authorizer_type = f"{type(self._authorizer).__module__}.{type(self._authorizer).__name__}"
            raise TypeError(
                f"Authorizer '{authorizer_type}' "
                f"returned unexpected type '{type(authorization_decision).__name__}' "
                f"for method '{method_name}' on '{headers.actor_id}'"
            ) from e

        # If the decision is not `True`, raise a `SystemAborted` with either a
        # `PermissionDenied` error (in case of `False`) or an `Unauthenticated`
        # error.
        if not isinstance(authorization_decision, resemble.v1alpha1.errors_pb2.Ok):
            if isinstance(authorization_decision, resemble.v1alpha1.errors_pb2.Unauthenticated):
                logger.warning(
                    "Unauthenticated call to "
                    f"'{method_name}' on '{headers.actor_id}'"
                )

            raise resemble.aio.aborted.SystemAborted(
                authorization_decision,
                message=
                f'You are not authorized to call {method_name} on '
                f"'{headers.actor_id}'"
            )

    async def _maybe_verify_token(self, headers) -> Optional[resemble.aio.auth.Auth]:
        """Verify the bearer token and if a token verifier is present.

        Returns the (optional) `resemble.aio.auth.Auth` object
        produced by the token verifier if the token can be verified.
        """
        auth: Optional[resemble.aio.auth.Auth] = None

        if self._token_verifier is not None and headers.bearer_token is not None:
            if headers.bearer_token == __internal_magic_token__:
                return auth

            with self.use_context(
                headers=(
                    # Get headers suitable for doing token verification.
                    headers.copy_for_token_verification_and_authorization()
                ),
                context_type=ReaderContext,
            ) as context:
                auth = await self._token_verifier.verify_token(
                    context=context,
                    token=headers.bearer_token,
                )

        return auth


class _ApplicationStub(Stub):

    __service_name__ = ServiceName('resemble.cloud.v1alpha1.application.ApplicationInterface')

    def __init__(
        self,
        *,
        context_or_workflow: Context | Workflow,
        actor_id: ActorId,
        bearer_token: Optional[str] = None,
    ):
        context: Optional[Context] = None

        if isinstance(context_or_workflow, Context):
            context = context_or_workflow

            # ISSUE(https://github.com/reboot-dev/respect/issues/2258)
            # For now we do not explicitly pass on the bearer token here, as it
            # might have security implications to just pass on the token to any
            # service we are calling.

        elif isinstance(context_or_workflow, Workflow):
            bearer_token = context_or_workflow.bearer_token

        super().__init__(
            channel_manager=context_or_workflow.channel_manager,
            idempotency_manager=context_or_workflow,
            service_name=self.__service_name__,
            actor_id=actor_id,
            context=context,
            bearer_token=bearer_token,
        )

        channel = self._channel_manager.get_channel_for(
            self.__service_name__, actor_id
        )
        self._stub = resemble.cloud.v1alpha1.application.application_pb2_grpc.ApplicationInterfaceStub(channel)


class ApplicationReaderStub(_ApplicationStub):

    def __init__(
        self,
        context_or_workflow: ReaderContext | WriterContext | TransactionContext | WorkflowContext | Workflow,
        *,
        actor_id: ActorId,
        bearer_token: Optional[str] = None,
    ):
        assert_type(context_or_workflow, [ReaderContext, WriterContext, TransactionContext, WorkflowContext, Workflow])
        super().__init__(
            context_or_workflow=context_or_workflow,
            actor_id=actor_id,
            bearer_token=bearer_token,
        )

    # Application specific methods:







class ApplicationWriterStub(_ApplicationStub):

    def __init__(
        self,
        context_or_workflow: TransactionContext | WorkflowContext | Workflow,
        *,
        actor_id: ActorId,
        bearer_token: Optional[str] = None,
    ):
        assert_type(context_or_workflow, [TransactionContext, WorkflowContext, Workflow])
        super().__init__(
            context_or_workflow=context_or_workflow,
            actor_id=actor_id,
            bearer_token=bearer_token,
        )

    # Application specific methods:
    async def Create(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.CreateRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.CreateResponse:
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Create',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'Create',
                self._stub.Create,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.CreateResponse,
                aborted_type=Application.CreateAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call

    async def Up(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.UpResponse:
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Up',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'Up',
                self._stub.Up,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.UpResponse,
                aborted_type=Application.UpAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call

    async def UpTask(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse:
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='UpTask',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'UpTask',
                self._stub.UpTask,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse,
                aborted_type=Application.UpTaskAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call

    async def Down(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.DownResponse:
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Down',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'Down',
                self._stub.Down,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.DownResponse,
                aborted_type=Application.DownAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call

    async def DownTask(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse:
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='DownTask',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'DownTask',
                self._stub.DownTask,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse,
                aborted_type=Application.DownTaskAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call


class ApplicationWorkflowStub(_ApplicationStub):

    def __init__(
        self,
        *,
        context_or_workflow: TransactionContext | WorkflowContext | Workflow,
        actor_id: ActorId,
        bearer_token: Optional[str] = None,
    ):
        assert_type(context_or_workflow, [TransactionContext, WorkflowContext, Workflow])
        super().__init__(
            context_or_workflow=context_or_workflow,
            actor_id=actor_id,
            bearer_token=bearer_token,
        )

    # Application specific methods:
    async def Create(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.CreateRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.CreateResponse:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Create',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'Create',
                self._stub.Create,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.CreateResponse,
                aborted_type=Application.CreateAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call

    async def Up(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.UpResponse:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Up',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'Up',
                self._stub.Up,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.UpResponse,
                aborted_type=Application.UpAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call

    async def UpTask(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='UpTask',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'UpTask',
                self._stub.UpTask,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse,
                aborted_type=Application.UpTaskAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call

    async def Down(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.DownResponse:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Down',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'Down',
                self._stub.Down,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.DownResponse,
                aborted_type=Application.DownAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call

    async def DownTask(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='DownTask',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'DownTask',
                self._stub.DownTask,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse,
                aborted_type=Application.DownTaskAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call



class ApplicationTasksStub(_ApplicationStub):

    def __init__(
        self,
        context_or_workflow: TransactionContext | WorkflowContext | Workflow,
        *,
        actor_id: ActorId,
        bearer_token: Optional[str] = None,
    ):
        assert_type(context_or_workflow, [TransactionContext, WorkflowContext, Workflow])
        super().__init__(
            context_or_workflow=context_or_workflow,
            actor_id=actor_id,
            bearer_token=bearer_token,
        )

    # Application specific methods:
    async def Create(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.CreateRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> tasks_pb2.TaskId:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Create',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'Create',
                self._stub.Create,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.CreateResponse,
                aborted_type=Application.CreateAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                await call
                for (key, value) in await call.trailing_metadata():  # type: ignore[attr-defined]
                    if key == resemble.aio.headers.TASK_ID_UUID:
                        return tasks_pb2.TaskId(
                            state_type=self._headers.state_type_name,
                            actor_id=self._headers.actor_id,
                            task_uuid=uuid.UUID(value).bytes,
                        )
                raise resemble.aio.aborted.SystemAborted(
                    resemble.v1alpha1.errors_pb2.Internal(),
                    message='Trailing metadata missing for task schedule',
                )

    async def Up(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> tasks_pb2.TaskId:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Up',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'Up',
                self._stub.Up,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.UpResponse,
                aborted_type=Application.UpAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                await call
                for (key, value) in await call.trailing_metadata():  # type: ignore[attr-defined]
                    if key == resemble.aio.headers.TASK_ID_UUID:
                        return tasks_pb2.TaskId(
                            state_type=self._headers.state_type_name,
                            actor_id=self._headers.actor_id,
                            task_uuid=uuid.UUID(value).bytes,
                        )
                raise resemble.aio.aborted.SystemAborted(
                    resemble.v1alpha1.errors_pb2.Internal(),
                    message='Trailing metadata missing for task schedule',
                )

    async def UpTask(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> tasks_pb2.TaskId:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='UpTask',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'UpTask',
                self._stub.UpTask,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse,
                aborted_type=Application.UpTaskAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                await call
                for (key, value) in await call.trailing_metadata():  # type: ignore[attr-defined]
                    if key == resemble.aio.headers.TASK_ID_UUID:
                        return tasks_pb2.TaskId(
                            state_type=self._headers.state_type_name,
                            actor_id=self._headers.actor_id,
                            task_uuid=uuid.UUID(value).bytes,
                        )
                raise resemble.aio.aborted.SystemAborted(
                    resemble.v1alpha1.errors_pb2.Internal(),
                    message='Trailing metadata missing for task schedule',
                )

    async def Down(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> tasks_pb2.TaskId:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Down',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'Down',
                self._stub.Down,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.DownResponse,
                aborted_type=Application.DownAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                await call
                for (key, value) in await call.trailing_metadata():  # type: ignore[attr-defined]
                    if key == resemble.aio.headers.TASK_ID_UUID:
                        return tasks_pb2.TaskId(
                            state_type=self._headers.state_type_name,
                            actor_id=self._headers.actor_id,
                            task_uuid=uuid.UUID(value).bytes,
                        )
                raise resemble.aio.aborted.SystemAborted(
                    resemble.v1alpha1.errors_pb2.Internal(),
                    message='Trailing metadata missing for task schedule',
                )

    async def DownTask(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
        bearer_token: Optional[str] = None,
    ) -> tasks_pb2.TaskId:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='DownTask',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'DownTask',
                self._stub.DownTask,
                request,
                unary=True,
                reader=False,
                response_type=resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse,
                aborted_type=Application.DownTaskAborted,
                metadata=metadata,
                idempotency_key=idempotency_key,
                bearer_token=bearer_token,
            ) as call:
                assert isinstance(call, Awaitable)
                await call
                for (key, value) in await call.trailing_metadata():  # type: ignore[attr-defined]
                    if key == resemble.aio.headers.TASK_ID_UUID:
                        return tasks_pb2.TaskId(
                            state_type=self._headers.state_type_name,
                            actor_id=self._headers.actor_id,
                            task_uuid=uuid.UUID(value).bytes,
                        )
                raise resemble.aio.aborted.SystemAborted(
                    resemble.v1alpha1.errors_pb2.Internal(),
                    message='Trailing metadata missing for task schedule',
                )



class ApplicationServicerTasksStub(_ApplicationStub):

    def __init__(
        self,
        context: WriterContext,
        *,
        actor_id: ActorId,
        bearer_token: Optional[str] = None,
    ):
        assert_type(context, [WriterContext])
        super().__init__(
            context_or_workflow=context,
            actor_id=actor_id,
            bearer_token=bearer_token,
        )

    # Application specific methods:
    def Create(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.CreateRequest,
        *,
        schedule: Optional[datetime | timedelta] = None,
    ) -> TaskEffect:
        return TaskEffect(
            service_name=self.__service_name__,
            actor_id=self._headers.actor_id,
            method_name='Create',
            request=request,
            schedule=(datetime.now() + schedule) if isinstance(
                schedule, timedelta
            ) else schedule,
        )

    def Up(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        *,
        schedule: Optional[datetime | timedelta] = None,
    ) -> TaskEffect:
        return TaskEffect(
            service_name=self.__service_name__,
            actor_id=self._headers.actor_id,
            method_name='Up',
            request=request,
            schedule=(datetime.now() + schedule) if isinstance(
                schedule, timedelta
            ) else schedule,
        )

    def UpTask(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
        *,
        schedule: Optional[datetime | timedelta] = None,
    ) -> TaskEffect:
        return TaskEffect(
            service_name=self.__service_name__,
            actor_id=self._headers.actor_id,
            method_name='UpTask',
            request=request,
            schedule=(datetime.now() + schedule) if isinstance(
                schedule, timedelta
            ) else schedule,
        )

    def Down(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownRequest,
        *,
        schedule: Optional[datetime | timedelta] = None,
    ) -> TaskEffect:
        return TaskEffect(
            service_name=self.__service_name__,
            actor_id=self._headers.actor_id,
            method_name='Down',
            request=request,
            schedule=(datetime.now() + schedule) if isinstance(
                schedule, timedelta
            ) else schedule,
        )

    def DownTask(
        self,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest,
        *,
        schedule: Optional[datetime | timedelta] = None,
    ) -> TaskEffect:
        return TaskEffect(
            service_name=self.__service_name__,
            actor_id=self._headers.actor_id,
            method_name='DownTask',
            request=request,
            schedule=(datetime.now() + schedule) if isinstance(
                schedule, timedelta
            ) else schedule,
        )



class ApplicationAuthorizerMixin:
    """Mixin that provides a default implementation of the `can_authorize`
    method for all Application authorizers.
    """

    def can_authorize(self, method_name: str) -> bool:
        service_method_names = [
            'resemble.cloud.v1alpha1.application.Application.Create',
            'resemble.cloud.v1alpha1.application.Application.Up',
            'resemble.cloud.v1alpha1.application.Application.UpTask',
            'resemble.cloud.v1alpha1.application.Application.Down',
            'resemble.cloud.v1alpha1.application.Application.DownTask',
        ]
        return method_name in service_method_names


ApplicationStateType: TypeAlias = resemble.cloud.v1alpha1.application.application_pb2.Application
ApplicationRequestTypes: TypeAlias = \
        resemble.cloud.v1alpha1.application.application_pb2.CreateRequest \
        | resemble.cloud.v1alpha1.application.application_pb2.UpRequest \
        | resemble.cloud.v1alpha1.application.application_pb2.UpRequest \
        | resemble.cloud.v1alpha1.application.application_pb2.DownRequest \
        | resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest


class ApplicationAuthorizer(
    ApplicationAuthorizerMixin,
    resemble.aio.auth.authorizers.Authorizer[ApplicationStateType, ApplicationRequestTypes],
):
    StateType: TypeAlias = ApplicationStateType
    RequestTypes: TypeAlias = ApplicationRequestTypes

    async def authorize(
        self,
        *,
        method_name: str,
        context: ReaderContext,
        state: Optional[ApplicationStateType] = None,
        request: Optional[ApplicationRequestTypes] = None,
    ) -> resemble.aio.auth.authorizers.Authorizer.Decision:
        if method_name == 'resemble.cloud.v1alpha1.application.Application.Create':
            return await self.Create(
                context,
                cast(resemble.cloud.v1alpha1.application.application_pb2.CreateRequest, request),
            )
        elif method_name == 'resemble.cloud.v1alpha1.application.Application.Up':
            return await self.Up(
                context,
                cast(resemble.cloud.v1alpha1.application.application_pb2.Application, state),
                cast(resemble.cloud.v1alpha1.application.application_pb2.UpRequest, request),
            )
        elif method_name == 'resemble.cloud.v1alpha1.application.Application.UpTask':
            return await self.UpTask(
                context,
                cast(resemble.cloud.v1alpha1.application.application_pb2.Application, state),
                cast(resemble.cloud.v1alpha1.application.application_pb2.UpRequest, request),
            )
        elif method_name == 'resemble.cloud.v1alpha1.application.Application.Down':
            return await self.Down(
                context,
                cast(resemble.cloud.v1alpha1.application.application_pb2.Application, state),
                cast(resemble.cloud.v1alpha1.application.application_pb2.DownRequest, request),
            )
        elif method_name == 'resemble.cloud.v1alpha1.application.Application.DownTask':
            return await self.DownTask(
                context,
                cast(resemble.cloud.v1alpha1.application.application_pb2.Application, state),
                cast(resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest, request),
            )
        else:
            return resemble.v1alpha1.errors_pb2.PermissionDenied()

    async def Create(
        self,
        context: ReaderContext,
        request: resemble.cloud.v1alpha1.application.application_pb2.CreateRequest,
    ) -> resemble.aio.auth.authorizers.Authorizer.Decision:
        return resemble.v1alpha1.errors_pb2.PermissionDenied()

    async def Up(
        self,
        context: ReaderContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
    ) -> resemble.aio.auth.authorizers.Authorizer.Decision:
        return resemble.v1alpha1.errors_pb2.PermissionDenied()

    async def UpTask(
        self,
        context: ReaderContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
    ) -> resemble.aio.auth.authorizers.Authorizer.Decision:
        return resemble.v1alpha1.errors_pb2.PermissionDenied()

    async def Down(
        self,
        context: ReaderContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownRequest,
    ) -> resemble.aio.auth.authorizers.Authorizer.Decision:
        return resemble.v1alpha1.errors_pb2.PermissionDenied()

    async def DownTask(
        self,
        context: ReaderContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest,
    ) -> resemble.aio.auth.authorizers.Authorizer.Decision:
        return resemble.v1alpha1.errors_pb2.PermissionDenied()


    # Off-the shelf authorizers for Application:

    class AllowAllIfAuthenticated(
        ApplicationAuthorizerMixin,
        resemble.aio.auth.authorizers.Authorizer,
    ):
        """An authorizer for Application that allows all requests if the
        caller is authenticated.
        """
        async def authorize(
            self,
            *,
            method_name: str,
            context: ReaderContext,
            state: Optional[ApplicationStateType] = None,
            request: Optional[ApplicationRequestTypes] = None,
        ) -> resemble.aio.auth.authorizers.Authorizer.Decision:
            if context.auth is None:
                return resemble.v1alpha1.errors_pb2.Unauthenticated()

            return resemble.v1alpha1.errors_pb2.Ok()


class ApplicationServicer(Servicer):
    Authorizer: TypeAlias = ApplicationAuthorizer

    __service_name__ = ServiceName('resemble.cloud.v1alpha1.application.ApplicationInterface')
    __file_descriptor__ = resemble.cloud.v1alpha1.application.application_pb2.DESCRIPTOR
    __state_type__ = resemble.cloud.v1alpha1.application.application_pb2.Application

    def __init__(self):
        # NOTE: need to hold on to the middleware so we can do inline
        # writes (see 'self.write(...)').
        #
        # Because '_middleware' is not really private this does mean
        # users may do possibly dangerous things, but this is no more
        # likely given they could have already overridden
        # 'create_middleware()'.
        self._middleware: Optional[ApplicationServicerMiddleware] = None

    def create_middleware(
        self,
        *,
        application_id: ApplicationId,
        state_manager: StateManager,
        channel_manager: _ChannelManager,
        tasks_cache: TasksCache,
        token_verifier: Optional[resemble.aio.auth.token_verifiers.TokenVerifier],
        effect_validation: EffectValidation,
        ready: asyncio.Event,
    ) -> ApplicationServicerMiddleware:
        self._middleware = ApplicationServicerMiddleware(
            servicer=self,
            application_id=application_id,
            state_manager=state_manager,
            channel_manager=channel_manager,
            tasks_cache=tasks_cache,
            token_verifier=token_verifier,
            effect_validation=effect_validation,
            ready=ready,
        )
        return self._middleware

    def authorizer(self) -> Optional[resemble.aio.auth.authorizers.Authorizer]:
        return None

    def token_verifier(self) -> Optional[resemble.aio.auth.token_verifiers.TokenVerifier]:
        return None

    def lookup(
        self,
        *,
        bearer_token: Optional[str] = None,
    ) -> Application.WeakReference:
        # TODO(benh): it's still possible that the `bearer_token` from
        # the context will not be sufficient for making a
        # call/schedule due to a user defined authorizer; consider
        # creating a "per middleware" bearer token that always works
        # for calls from `self.lookup()`.
        context = Context.get()

        if context is None:
            raise RuntimeError(
                'Missing asyncio context variable `context`; '
                'are you using this class without Resemble?'
            )

        return Application.WeakReference(
            actor_id=context.actor_id,
            bearer_token=bearer_token or context.bearer_token,
        )

    class _Schedule:

        def __init__(
            self,
            *,
            when: Optional[datetime | timedelta] = None,
        ):
            self._when = when

        # Application specific methods:
        def Up(
            self,
            __context__: WriterContext,
            *,
            container_image_name: Optional[str] = None,
        ) -> TaskEffect:
            if container_image_name is not None and not isinstance(
                container_image_name,
                str,
            ):
                raise TypeError(
                    f"Can not construct protobuf message of type "
                    f"'resemble.cloud.v1alpha1.application.application_pb2.UpRequest': field 'container_image_name' is not "
                    f"of required type 'str'"
                )
            # TODO: mypy-protobuf declares that
            # `google.protobuf.message.Message` constructor arguments
            # are always non-None, when in reality they are optional.
            request = resemble.cloud.v1alpha1.application.application_pb2.UpRequest(
                container_image_name=container_image_name,  # type: ignore[arg-type]
            )
            return ApplicationServicerTasksStub(
                context=__context__,
                actor_id=__context__.actor_id,
            ).Up(
                request,
                schedule=self._when,
            )

        def UpTask(
            self,
            __context__: WriterContext,
            *,
            container_image_name: Optional[str] = None,
        ) -> TaskEffect:
            if container_image_name is not None and not isinstance(
                container_image_name,
                str,
            ):
                raise TypeError(
                    f"Can not construct protobuf message of type "
                    f"'resemble.cloud.v1alpha1.application.application_pb2.UpRequest': field 'container_image_name' is not "
                    f"of required type 'str'"
                )
            # TODO: mypy-protobuf declares that
            # `google.protobuf.message.Message` constructor arguments
            # are always non-None, when in reality they are optional.
            request = resemble.cloud.v1alpha1.application.application_pb2.UpRequest(
                container_image_name=container_image_name,  # type: ignore[arg-type]
            )
            return ApplicationServicerTasksStub(
                context=__context__,
                actor_id=__context__.actor_id,
            ).UpTask(
                request,
                schedule=self._when,
            )

        def Down(
            self,
            __context__: WriterContext,
        ) -> TaskEffect:
            # TODO: mypy-protobuf declares that
            # `google.protobuf.message.Message` constructor arguments
            # are always non-None, when in reality they are optional.
            request = resemble.cloud.v1alpha1.application.application_pb2.DownRequest(
            )
            return ApplicationServicerTasksStub(
                context=__context__,
                actor_id=__context__.actor_id,
            ).Down(
                request,
                schedule=self._when,
            )

        def DownTask(
            self,
            __context__: WriterContext,
        ) -> TaskEffect:
            # TODO: mypy-protobuf declares that
            # `google.protobuf.message.Message` constructor arguments
            # are always non-None, when in reality they are optional.
            request = resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest(
            )
            return ApplicationServicerTasksStub(
                context=__context__,
                actor_id=__context__.actor_id,
            ).DownTask(
                request,
                schedule=self._when,
            )


    def schedule(
        self,
        *,
        when: Optional[datetime | timedelta] = None,
    ) -> ApplicationServicer._Schedule:
        return ApplicationServicer._Schedule(when=when)

    class Effects(resemble.aio.state_managers.Effects):
        def __init__(
            self,
            *,
            state: resemble.cloud.v1alpha1.application.application_pb2.Application,
            response: Optional[google.protobuf.message.Message] = None,
            tasks: Optional[list[TaskEffect]] = None,
            _interleaved_upserts: Optional[list[tuple[str, Optional[bytes]]]] = None,
        ):
            assert_type(state, [resemble.cloud.v1alpha1.application.application_pb2.Application])

            super().__init__(state=state, response=response, tasks=tasks, _interleaved_upserts=_interleaved_upserts)

    class CreateEffects(Effects):
        def __init__(
            self,
            *,
            state: resemble.cloud.v1alpha1.application.application_pb2.Application,
            response: resemble.cloud.v1alpha1.application.application_pb2.CreateResponse,
            tasks: Optional[list[TaskEffect]] = None,
            _interleaved_upserts: Optional[list[tuple[str, Optional[bytes]]]] = None,
        ):
            assert_type(state, [resemble.cloud.v1alpha1.application.application_pb2.Application])
            assert_type(response, [resemble.cloud.v1alpha1.application.application_pb2.CreateResponse])

            super().__init__(state=state, response=response, tasks=tasks, _interleaved_upserts=_interleaved_upserts)


    class UpEffects(Effects):
        def __init__(
            self,
            *,
            state: resemble.cloud.v1alpha1.application.application_pb2.Application,
            response: resemble.cloud.v1alpha1.application.application_pb2.UpResponse,
            tasks: Optional[list[TaskEffect]] = None,
            _interleaved_upserts: Optional[list[tuple[str, Optional[bytes]]]] = None,
        ):
            assert_type(state, [resemble.cloud.v1alpha1.application.application_pb2.Application])
            assert_type(response, [resemble.cloud.v1alpha1.application.application_pb2.UpResponse])

            super().__init__(state=state, response=response, tasks=tasks, _interleaved_upserts=_interleaved_upserts)


    class UpTaskEffects(Effects):
        def __init__(
            self,
            *,
            state: resemble.cloud.v1alpha1.application.application_pb2.Application,
            response: resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse,
            tasks: Optional[list[TaskEffect]] = None,
            _interleaved_upserts: Optional[list[tuple[str, Optional[bytes]]]] = None,
        ):
            assert_type(state, [resemble.cloud.v1alpha1.application.application_pb2.Application])
            assert_type(response, [resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse])

            super().__init__(state=state, response=response, tasks=tasks, _interleaved_upserts=_interleaved_upserts)


    class DownEffects(Effects):
        def __init__(
            self,
            *,
            state: resemble.cloud.v1alpha1.application.application_pb2.Application,
            response: resemble.cloud.v1alpha1.application.application_pb2.DownResponse,
            tasks: Optional[list[TaskEffect]] = None,
            _interleaved_upserts: Optional[list[tuple[str, Optional[bytes]]]] = None,
        ):
            assert_type(state, [resemble.cloud.v1alpha1.application.application_pb2.Application])
            assert_type(response, [resemble.cloud.v1alpha1.application.application_pb2.DownResponse])

            super().__init__(state=state, response=response, tasks=tasks, _interleaved_upserts=_interleaved_upserts)


    class DownTaskEffects(Effects):
        def __init__(
            self,
            *,
            state: resemble.cloud.v1alpha1.application.application_pb2.Application,
            response: resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse,
            tasks: Optional[list[TaskEffect]] = None,
            _interleaved_upserts: Optional[list[tuple[str, Optional[bytes]]]] = None,
        ):
            assert_type(state, [resemble.cloud.v1alpha1.application.application_pb2.Application])
            assert_type(response, [resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse])

            super().__init__(state=state, response=response, tasks=tasks, _interleaved_upserts=_interleaved_upserts)



    class InlineWriterCallable(typing.Protocol):
        async def __call__(
            self,
            context: WriterContext,
            state: resemble.cloud.v1alpha1.application.application_pb2.Application
        ) -> ApplicationServicer.Effects:
            ...

    async def read(
        self, context: TransactionContext | WorkflowContext
    ) -> resemble.cloud.v1alpha1.application.application_pb2.Application:
        """Read the current state within a transaction."""
        assert_type(context, [TransactionContext, WorkflowContext])

        if self._middleware is None:
            raise RuntimeError(
                'Resemble middleware was not created; '
                'are you using this class without Resemble?'
            )

        return await self._middleware._state_manager.read(
            context, self.__state_type__
        )

    async def write(
        self,
        context: TransactionContext | WorkflowContext,
        writer: InlineWriterCallable,
        __options__: Optional[resemble.aio.call.Options] = None,
    ):
        """Perform an "inline write" within a transaction or task."""
        assert_type(context, [TransactionContext, WorkflowContext])

        if self._middleware is None:
            raise RuntimeError(
                'Resemble middleware was not created; '
                'are you using this class without Resemble?'
            )

        idempotency: Optional[resemble.aio.idempotency.Idempotency] = None
        metadata: Optional[resemble.aio.types.GrpcMetadata] = None

        if __options__ is not None:
            if __options__.idempotency_key is not None:
                idempotency = Idempotency(key=__options__.idempotency_key)
            elif __options__.idempotency_alias is not None:
                idempotency = Idempotency(alias=__options__.idempotency_alias)
            if __options__.metadata is not None:
                metadata = __options__.metadata

        if metadata is None:
            metadata = ()

        headers = Headers(
            application_id=context.application_id,
            service_name=self.__service_name__,
            actor_id=context.actor_id,
            transaction_id=context.transaction_id,
            transaction_coordinator_service=context
            .transaction_coordinator_service,
            transaction_coordinator_actor_id=context
            .transaction_coordinator_actor_id
        )

        metadata += headers.to_grpc_metadata()

        idempotency_key: Optional[str]
        with context.idempotently(
            service=self.__service_name__,
            actor_id=context.actor_id,
            method=None,
            request=None,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:

            if any(t[0] == resemble.aio.headers.IDEMPOTENCY_KEY_HEADER for t in metadata):
                raise ValueError(
                    f"Do not set '{resemble.aio.headers.IDEMPOTENCY_KEY_HEADER}' metadata yourself"
                )

            if idempotency_key is not None:
                metadata += (
                    (resemble.aio.headers.IDEMPOTENCY_KEY_HEADER, idempotency_key),
                )

            with self._middleware.use_context(
                headers=Headers.from_grpc_metadata(metadata),
                context_type=WriterContext,
            ) as writer_context:
                # Check if we already have performed this mutation!
                #
                # We do this _before_ calling 'transactionally()' because
                # if this call is for a transaction method _and_ we've
                # already performed the transaction then we don't want to
                # become a transaction participant (again) we just want to
                # return the transaction's response.
                idempotent_mutation = (
                    self._middleware._state_manager.check_for_idempotent_mutation(
                        writer_context
                    )
                )

                if idempotent_mutation is not None:
                    # NOTE: invariant for now is that inline writers can't
                    # have responses which we also check for below.
                    assert len(idempotent_mutation.response) == 0
                    return

                async with self._middleware._state_manager.transactionally(
                    writer_context, self._middleware.tasks_dispatcher
                ) as transaction:
                    async with self._middleware._state_manager.writer(
                        writer_context,
                        self.__state_type__,
                        transaction=transaction,
                    ) as (state, state_manager_writer):
                        effects: ApplicationServicer.Effects = await writer(
                            context=writer_context, state=state
                        )

                        assert_type(
                            effects,
                            [ApplicationServicer.Effects],
                            may_be_subclass=False,
                        )

                        # TODO(benh): figure out if we want to support
                        # returning a response because we don't know how
                        # to parse it from an idempotent mutation.
                        if effects.response is not None:
                            raise ValueError(
                                'Returning a response from an inline writer '
                                'is not supported'
                            )

                        # All idempotent mutations require a reponse, so
                        # for now we just use `Empty`.
                        effects.response = empty_pb2.Empty()

                        if effects.tasks is not None:
                            # NOTE: we validate tasks added as part of a
                            # transaction when we prepare.
                            if transaction is None:
                                await self._middleware.tasks_dispatcher.validate(
                                    effects.tasks
                                )

                        await state_manager_writer.complete(effects)

                        if effects.tasks is not None:
                            if transaction is None:
                                self._middleware.tasks_dispatcher.dispatch(effects.tasks)
                            else:
                                assert all(
                                    task.task_id.state_type == transaction.state_type
                                    for task in effects.tasks
                                ), 'Task state type does not match transaction state type'
                                transaction.tasks.extend(effects.tasks)

    # Application specific methods:
    class _Idempotently:

        def __init__(
            self,
            *,
            servicer: ApplicationServicer,
            alias: Optional[str],
            key: Optional[str],
        ):
            self._servicer = servicer
            self._alias = alias
            self._key = key

        async def write(
            self,
            context: TransactionContext | WorkflowContext,
            writer: ApplicationServicer.InlineWriterCallable,
            __options__: resemble.aio.call.Options = resemble.aio.call.Options(),
        ):
            if __options__.idempotency_key is not None:
                raise RuntimeError(
                    'Found redundant idempotency key in `Options`'
                )

            if __options__.idempotency_alias is not None:
                raise RuntimeError(
                    'Found redundant idempotency alias in `Options`'
                )

            if self._alias is not None:
                assert self._key is None
                __options__ = dataclasses.replace(
                    __options__,
                    idempotency_alias=self._alias,
                )
            elif self._key is not None:
                assert self._alias is None
                __options__ = dataclasses.replace(
                    __options__,
                    idempotency_key=self._key,
                )

            return await self._servicer.write(context, writer, __options__)

    def idempotently(
        self,
        alias: Optional[str] = None,
        *,
        key: Optional[str] = None,
    ) -> ApplicationServicer._Idempotently:
        if (
            (alias is None and key is None) or
            (alias is not None and key is not None)
        ):
            raise RuntimeError(
                'Exactly one of the positional argument `alias` '
                'or the keyword argument `key` should be specified; '
                f'see {resemble.settings.DOCS_BASE_URL}/docs/model/safety_correctness/idempotency '
                'for more information'
            )

        return ApplicationServicer._Idempotently(
            servicer=self, alias=alias, key=key
        )

    # Application specific methods:
    @abstractmethod
    async def Create(
        self,
        context: WriterContext,
        request: resemble.cloud.v1alpha1.application.application_pb2.CreateRequest,
    ) -> CreateEffects:
        raise NotImplementedError

    @abstractmethod
    async def Up(
        self,
        context: WriterContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
    ) -> UpEffects:
        raise NotImplementedError

    @abstractmethod
    async def UpTask(
        self,
        context: WriterContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
    ) -> UpTaskEffects:
        raise NotImplementedError

    @abstractmethod
    async def Down(
        self,
        context: WriterContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownRequest,
    ) -> DownEffects:
        raise NotImplementedError

    @abstractmethod
    async def DownTask(
        self,
        context: WriterContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest,
    ) -> DownTaskEffects:
        raise NotImplementedError


class Application:

    Interface: TypeAlias = ApplicationServicer

    Effects: TypeAlias = ApplicationServicer.Effects

    Authorizer: TypeAlias = ApplicationAuthorizer

    State: TypeAlias = resemble.cloud.v1alpha1.application.application_pb2.Application

    class CreateFuture:
        """Represents a future corresponding to a task running on the
        actor. Note that this is not a coroutine because we are trying
        to convey the semantics that the task is already running (or
        will soon be) and thus we are just giving you a (distributed)
        future to it.
        """

        def __init__(
            self,
            context_or_workflow: Context | Workflow,
            *,
            task_id: tasks_pb2.TaskId,
        ) -> None:
            self._channel_manager = context_or_workflow.channel_manager
            self._task_id = task_id

        @property
        def task_id(self) -> tasks_pb2.TaskId:
            return self._task_id

        def __await__(self) -> Generator[None, None, resemble.cloud.v1alpha1.application.application_pb2.CreateResponse]:
            """Awaits for task to finish and returns it's response."""

            async def wait_for_task() -> resemble.cloud.v1alpha1.application.application_pb2.CreateResponse:
                channel = self._channel_manager.get_channel_from_state_type_name(
                    self._task_id.state_type, self._task_id.actor_id
                )

                stub = tasks_pb2_grpc.TasksStub(channel)

                try:
                    wait_for_task_response = await stub.Wait(
                        tasks_pb2.WaitRequest(task_id=self._task_id),
                        metadata=Headers(
                            service_name=state_type_to_service(self._task_id.state_type),
                            actor_id=self._task_id.actor_id,
                            # TODO(benh): will eventually be necessary to
                            # disambiguate between applications.
                            application_id=None,
                        ).to_grpc_metadata(),
                    )
                except grpc.aio.AioRpcError as error:
                    if error.code() == grpc.StatusCode.NOT_FOUND:
                        raise resemble.aio.aborted.SystemAborted(
                            resemble.v1alpha1.errors_pb2.UnknownTask()
                        ) from None

                    raise resemble.aio.aborted.SystemAborted.from_grpc_aio_rpc_error(
                        error
                    ) from None
                else:
                    response = resemble.cloud.v1alpha1.application.application_pb2.CreateResponse()

                    if (
                        wait_for_task_response.response.TypeName() !=
                        response.DESCRIPTOR.full_name
                    ):
                        raise resemble.aio.aborted.SystemAborted(
                            resemble.v1alpha1.errors_pb2.InvalidArgument(),
                            message=
                            f"task with UUID {str(uuid.UUID(bytes=self._task_id.task_uuid))} "
                            f"has a response of type '{wait_for_task_response.response.TypeName()}' "
                            "but expecting type 'resemble.cloud.v1alpha1.application.application_pb2.CreateResponse'; "
                            "are you waiting on a task of the correct method?",
                        ) from None

                    wait_for_task_response.response.Unpack(response)
                    return response

            return wait_for_task().__await__()

    CreateEffects: TypeAlias = Interface.CreateEffects

    class CreateAborted(resemble.aio.aborted.Aborted):


        Error = Union[
            resemble.aio.aborted.GrpcError,
            resemble.aio.aborted.ResembleError,
        ]

        METHOD_ERROR_TYPES: list[type[Error]] = [
        ]

        ERROR_TYPES: list[type[Error]] = (
            METHOD_ERROR_TYPES +
            resemble.aio.aborted.GRPC_ERROR_TYPES +
            resemble.aio.aborted.RESEMBLE_ERROR_TYPES
        )

        _error: Error
        _code: grpc.StatusCode
        _message: Optional[str]

        def __init__(
            self,
            error:  resemble.aio.aborted.GrpcError,
            *,
            message: Optional[str] = None,
            # Do not set this value when constructing in order to
            # raise. This is only used internally when constructing
            # from aborted calls.
            error_types: list[type[Error]] = (
                METHOD_ERROR_TYPES + resemble.aio.aborted.GRPC_ERROR_TYPES
            ),
        ):
            super().__init__()

            assert_type(error, error_types)

            self._error = error

            code = self.grpc_status_code_from_error(self._error)

            if code is None:
                # Must be a Resemble specific or declared method error.
                code = grpc.StatusCode.ABORTED

            self._code = code

            self._message = message

        @property
        def error(self) -> Error:
            return self._error

        @property
        def code(self) -> grpc.StatusCode:
            return self._code

        @property
        def message(self) -> Optional[str]:
            return self._message

        @classmethod
        def from_status(cls, status: status_pb2.Status):
            error = cls.error_from_google_rpc_status_details(
                status,
                cls.ERROR_TYPES,
            )

            message = status.message if len(status.message) > 0 else None

            if error is not None:
                return cls(error, message=message, error_types=cls.ERROR_TYPES)

            error = cls.error_from_google_rpc_status_code(status)

            assert error is not None

            # TODO(benh): also consider getting the type names from
            # `status.details` and including that in `message` to make
            # debugging easier.

            return cls(error, message=message)

        @classmethod
        def from_grpc_aio_rpc_error(cls, aio_rpc_error: grpc.aio.AioRpcError):
            return cls(
                cls.error_from_grpc_aio_rpc_error(aio_rpc_error),
                message=aio_rpc_error.details(),
            )

        @classmethod
        def is_declared_error(cls, message: google.protobuf.message.Message) -> bool:
            return False

    class UpFuture:
        """Represents a future corresponding to a task running on the
        actor. Note that this is not a coroutine because we are trying
        to convey the semantics that the task is already running (or
        will soon be) and thus we are just giving you a (distributed)
        future to it.
        """

        def __init__(
            self,
            context_or_workflow: Context | Workflow,
            *,
            task_id: tasks_pb2.TaskId,
        ) -> None:
            self._channel_manager = context_or_workflow.channel_manager
            self._task_id = task_id

        @property
        def task_id(self) -> tasks_pb2.TaskId:
            return self._task_id

        def __await__(self) -> Generator[None, None, resemble.cloud.v1alpha1.application.application_pb2.UpResponse]:
            """Awaits for task to finish and returns it's response."""

            async def wait_for_task() -> resemble.cloud.v1alpha1.application.application_pb2.UpResponse:
                channel = self._channel_manager.get_channel_from_state_type_name(
                    self._task_id.state_type, self._task_id.actor_id
                )

                stub = tasks_pb2_grpc.TasksStub(channel)

                try:
                    wait_for_task_response = await stub.Wait(
                        tasks_pb2.WaitRequest(task_id=self._task_id),
                        metadata=Headers(
                            service_name=state_type_to_service(self._task_id.state_type),
                            actor_id=self._task_id.actor_id,
                            # TODO(benh): will eventually be necessary to
                            # disambiguate between applications.
                            application_id=None,
                        ).to_grpc_metadata(),
                    )
                except grpc.aio.AioRpcError as error:
                    if error.code() == grpc.StatusCode.NOT_FOUND:
                        raise resemble.aio.aborted.SystemAborted(
                            resemble.v1alpha1.errors_pb2.UnknownTask()
                        ) from None

                    raise resemble.aio.aborted.SystemAborted.from_grpc_aio_rpc_error(
                        error
                    ) from None
                else:
                    response = resemble.cloud.v1alpha1.application.application_pb2.UpResponse()

                    if (
                        wait_for_task_response.response.TypeName() !=
                        response.DESCRIPTOR.full_name
                    ):
                        raise resemble.aio.aborted.SystemAborted(
                            resemble.v1alpha1.errors_pb2.InvalidArgument(),
                            message=
                            f"task with UUID {str(uuid.UUID(bytes=self._task_id.task_uuid))} "
                            f"has a response of type '{wait_for_task_response.response.TypeName()}' "
                            "but expecting type 'resemble.cloud.v1alpha1.application.application_pb2.UpResponse'; "
                            "are you waiting on a task of the correct method?",
                        ) from None

                    wait_for_task_response.response.Unpack(response)
                    return response

            return wait_for_task().__await__()

    UpEffects: TypeAlias = Interface.UpEffects

    class UpAborted(resemble.aio.aborted.Aborted):

        MethodError = Union[
resemble.cloud.v1alpha1.application.application_pb2.InvalidInputError        ]

        Error = Union[
            MethodError,
            resemble.aio.aborted.GrpcError,
            resemble.aio.aborted.ResembleError,
        ]

        METHOD_ERROR_TYPES: list[type[Error]] = [
resemble.cloud.v1alpha1.application.application_pb2.InvalidInputError        ]

        ERROR_TYPES: list[type[Error]] = (
            METHOD_ERROR_TYPES +
            resemble.aio.aborted.GRPC_ERROR_TYPES +
            resemble.aio.aborted.RESEMBLE_ERROR_TYPES
        )

        _error: Error
        _code: grpc.StatusCode
        _message: Optional[str]

        def __init__(
            self,
            error: MethodError |  resemble.aio.aborted.GrpcError,
            *,
            message: Optional[str] = None,
            # Do not set this value when constructing in order to
            # raise. This is only used internally when constructing
            # from aborted calls.
            error_types: list[type[Error]] = (
                METHOD_ERROR_TYPES + resemble.aio.aborted.GRPC_ERROR_TYPES
            ),
        ):
            super().__init__()

            assert_type(error, error_types)

            self._error = error

            code = self.grpc_status_code_from_error(self._error)

            if code is None:
                # Must be a Resemble specific or declared method error.
                code = grpc.StatusCode.ABORTED

            self._code = code

            self._message = message

        @property
        def error(self) -> Error:
            return self._error

        @property
        def code(self) -> grpc.StatusCode:
            return self._code

        @property
        def message(self) -> Optional[str]:
            return self._message

        @classmethod
        def from_status(cls, status: status_pb2.Status):
            error = cls.error_from_google_rpc_status_details(
                status,
                cls.ERROR_TYPES,
            )

            message = status.message if len(status.message) > 0 else None

            if error is not None:
                return cls(error, message=message, error_types=cls.ERROR_TYPES)

            error = cls.error_from_google_rpc_status_code(status)

            assert error is not None

            # TODO(benh): also consider getting the type names from
            # `status.details` and including that in `message` to make
            # debugging easier.

            return cls(error, message=message)

        @classmethod
        def from_grpc_aio_rpc_error(cls, aio_rpc_error: grpc.aio.AioRpcError):
            return cls(
                cls.error_from_grpc_aio_rpc_error(aio_rpc_error),
                message=aio_rpc_error.details(),
            )

        @classmethod
        def is_declared_error(cls, message: google.protobuf.message.Message) -> bool:
            if message.DESCRIPTOR.full_name == 'resemble.cloud.v1alpha1.application.InvalidInputError':
                return True
            return False

    class UpTaskFuture:
        """Represents a future corresponding to a task running on the
        actor. Note that this is not a coroutine because we are trying
        to convey the semantics that the task is already running (or
        will soon be) and thus we are just giving you a (distributed)
        future to it.
        """

        def __init__(
            self,
            context_or_workflow: Context | Workflow,
            *,
            task_id: tasks_pb2.TaskId,
        ) -> None:
            self._channel_manager = context_or_workflow.channel_manager
            self._task_id = task_id

        @property
        def task_id(self) -> tasks_pb2.TaskId:
            return self._task_id

        def __await__(self) -> Generator[None, None, resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse]:
            """Awaits for task to finish and returns it's response."""

            async def wait_for_task() -> resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse:
                channel = self._channel_manager.get_channel_from_state_type_name(
                    self._task_id.state_type, self._task_id.actor_id
                )

                stub = tasks_pb2_grpc.TasksStub(channel)

                try:
                    wait_for_task_response = await stub.Wait(
                        tasks_pb2.WaitRequest(task_id=self._task_id),
                        metadata=Headers(
                            service_name=state_type_to_service(self._task_id.state_type),
                            actor_id=self._task_id.actor_id,
                            # TODO(benh): will eventually be necessary to
                            # disambiguate between applications.
                            application_id=None,
                        ).to_grpc_metadata(),
                    )
                except grpc.aio.AioRpcError as error:
                    if error.code() == grpc.StatusCode.NOT_FOUND:
                        raise resemble.aio.aborted.SystemAborted(
                            resemble.v1alpha1.errors_pb2.UnknownTask()
                        ) from None

                    raise resemble.aio.aborted.SystemAborted.from_grpc_aio_rpc_error(
                        error
                    ) from None
                else:
                    response = resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse()

                    if (
                        wait_for_task_response.response.TypeName() !=
                        response.DESCRIPTOR.full_name
                    ):
                        raise resemble.aio.aborted.SystemAborted(
                            resemble.v1alpha1.errors_pb2.InvalidArgument(),
                            message=
                            f"task with UUID {str(uuid.UUID(bytes=self._task_id.task_uuid))} "
                            f"has a response of type '{wait_for_task_response.response.TypeName()}' "
                            "but expecting type 'resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse'; "
                            "are you waiting on a task of the correct method?",
                        ) from None

                    wait_for_task_response.response.Unpack(response)
                    return response

            return wait_for_task().__await__()

    UpTaskEffects: TypeAlias = Interface.UpTaskEffects

    class UpTaskAborted(resemble.aio.aborted.Aborted):


        Error = Union[
            resemble.aio.aborted.GrpcError,
            resemble.aio.aborted.ResembleError,
        ]

        METHOD_ERROR_TYPES: list[type[Error]] = [
        ]

        ERROR_TYPES: list[type[Error]] = (
            METHOD_ERROR_TYPES +
            resemble.aio.aborted.GRPC_ERROR_TYPES +
            resemble.aio.aborted.RESEMBLE_ERROR_TYPES
        )

        _error: Error
        _code: grpc.StatusCode
        _message: Optional[str]

        def __init__(
            self,
            error:  resemble.aio.aborted.GrpcError,
            *,
            message: Optional[str] = None,
            # Do not set this value when constructing in order to
            # raise. This is only used internally when constructing
            # from aborted calls.
            error_types: list[type[Error]] = (
                METHOD_ERROR_TYPES + resemble.aio.aborted.GRPC_ERROR_TYPES
            ),
        ):
            super().__init__()

            assert_type(error, error_types)

            self._error = error

            code = self.grpc_status_code_from_error(self._error)

            if code is None:
                # Must be a Resemble specific or declared method error.
                code = grpc.StatusCode.ABORTED

            self._code = code

            self._message = message

        @property
        def error(self) -> Error:
            return self._error

        @property
        def code(self) -> grpc.StatusCode:
            return self._code

        @property
        def message(self) -> Optional[str]:
            return self._message

        @classmethod
        def from_status(cls, status: status_pb2.Status):
            error = cls.error_from_google_rpc_status_details(
                status,
                cls.ERROR_TYPES,
            )

            message = status.message if len(status.message) > 0 else None

            if error is not None:
                return cls(error, message=message, error_types=cls.ERROR_TYPES)

            error = cls.error_from_google_rpc_status_code(status)

            assert error is not None

            # TODO(benh): also consider getting the type names from
            # `status.details` and including that in `message` to make
            # debugging easier.

            return cls(error, message=message)

        @classmethod
        def from_grpc_aio_rpc_error(cls, aio_rpc_error: grpc.aio.AioRpcError):
            return cls(
                cls.error_from_grpc_aio_rpc_error(aio_rpc_error),
                message=aio_rpc_error.details(),
            )

        @classmethod
        def is_declared_error(cls, message: google.protobuf.message.Message) -> bool:
            return False

    class DownFuture:
        """Represents a future corresponding to a task running on the
        actor. Note that this is not a coroutine because we are trying
        to convey the semantics that the task is already running (or
        will soon be) and thus we are just giving you a (distributed)
        future to it.
        """

        def __init__(
            self,
            context_or_workflow: Context | Workflow,
            *,
            task_id: tasks_pb2.TaskId,
        ) -> None:
            self._channel_manager = context_or_workflow.channel_manager
            self._task_id = task_id

        @property
        def task_id(self) -> tasks_pb2.TaskId:
            return self._task_id

        def __await__(self) -> Generator[None, None, resemble.cloud.v1alpha1.application.application_pb2.DownResponse]:
            """Awaits for task to finish and returns it's response."""

            async def wait_for_task() -> resemble.cloud.v1alpha1.application.application_pb2.DownResponse:
                channel = self._channel_manager.get_channel_from_state_type_name(
                    self._task_id.state_type, self._task_id.actor_id
                )

                stub = tasks_pb2_grpc.TasksStub(channel)

                try:
                    wait_for_task_response = await stub.Wait(
                        tasks_pb2.WaitRequest(task_id=self._task_id),
                        metadata=Headers(
                            service_name=state_type_to_service(self._task_id.state_type),
                            actor_id=self._task_id.actor_id,
                            # TODO(benh): will eventually be necessary to
                            # disambiguate between applications.
                            application_id=None,
                        ).to_grpc_metadata(),
                    )
                except grpc.aio.AioRpcError as error:
                    if error.code() == grpc.StatusCode.NOT_FOUND:
                        raise resemble.aio.aborted.SystemAborted(
                            resemble.v1alpha1.errors_pb2.UnknownTask()
                        ) from None

                    raise resemble.aio.aborted.SystemAborted.from_grpc_aio_rpc_error(
                        error
                    ) from None
                else:
                    response = resemble.cloud.v1alpha1.application.application_pb2.DownResponse()

                    if (
                        wait_for_task_response.response.TypeName() !=
                        response.DESCRIPTOR.full_name
                    ):
                        raise resemble.aio.aborted.SystemAborted(
                            resemble.v1alpha1.errors_pb2.InvalidArgument(),
                            message=
                            f"task with UUID {str(uuid.UUID(bytes=self._task_id.task_uuid))} "
                            f"has a response of type '{wait_for_task_response.response.TypeName()}' "
                            "but expecting type 'resemble.cloud.v1alpha1.application.application_pb2.DownResponse'; "
                            "are you waiting on a task of the correct method?",
                        ) from None

                    wait_for_task_response.response.Unpack(response)
                    return response

            return wait_for_task().__await__()

    DownEffects: TypeAlias = Interface.DownEffects

    class DownAborted(resemble.aio.aborted.Aborted):


        Error = Union[
            resemble.aio.aborted.GrpcError,
            resemble.aio.aborted.ResembleError,
        ]

        METHOD_ERROR_TYPES: list[type[Error]] = [
        ]

        ERROR_TYPES: list[type[Error]] = (
            METHOD_ERROR_TYPES +
            resemble.aio.aborted.GRPC_ERROR_TYPES +
            resemble.aio.aborted.RESEMBLE_ERROR_TYPES
        )

        _error: Error
        _code: grpc.StatusCode
        _message: Optional[str]

        def __init__(
            self,
            error:  resemble.aio.aborted.GrpcError,
            *,
            message: Optional[str] = None,
            # Do not set this value when constructing in order to
            # raise. This is only used internally when constructing
            # from aborted calls.
            error_types: list[type[Error]] = (
                METHOD_ERROR_TYPES + resemble.aio.aborted.GRPC_ERROR_TYPES
            ),
        ):
            super().__init__()

            assert_type(error, error_types)

            self._error = error

            code = self.grpc_status_code_from_error(self._error)

            if code is None:
                # Must be a Resemble specific or declared method error.
                code = grpc.StatusCode.ABORTED

            self._code = code

            self._message = message

        @property
        def error(self) -> Error:
            return self._error

        @property
        def code(self) -> grpc.StatusCode:
            return self._code

        @property
        def message(self) -> Optional[str]:
            return self._message

        @classmethod
        def from_status(cls, status: status_pb2.Status):
            error = cls.error_from_google_rpc_status_details(
                status,
                cls.ERROR_TYPES,
            )

            message = status.message if len(status.message) > 0 else None

            if error is not None:
                return cls(error, message=message, error_types=cls.ERROR_TYPES)

            error = cls.error_from_google_rpc_status_code(status)

            assert error is not None

            # TODO(benh): also consider getting the type names from
            # `status.details` and including that in `message` to make
            # debugging easier.

            return cls(error, message=message)

        @classmethod
        def from_grpc_aio_rpc_error(cls, aio_rpc_error: grpc.aio.AioRpcError):
            return cls(
                cls.error_from_grpc_aio_rpc_error(aio_rpc_error),
                message=aio_rpc_error.details(),
            )

        @classmethod
        def is_declared_error(cls, message: google.protobuf.message.Message) -> bool:
            return False

    class DownTaskFuture:
        """Represents a future corresponding to a task running on the
        actor. Note that this is not a coroutine because we are trying
        to convey the semantics that the task is already running (or
        will soon be) and thus we are just giving you a (distributed)
        future to it.
        """

        def __init__(
            self,
            context_or_workflow: Context | Workflow,
            *,
            task_id: tasks_pb2.TaskId,
        ) -> None:
            self._channel_manager = context_or_workflow.channel_manager
            self._task_id = task_id

        @property
        def task_id(self) -> tasks_pb2.TaskId:
            return self._task_id

        def __await__(self) -> Generator[None, None, resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse]:
            """Awaits for task to finish and returns it's response."""

            async def wait_for_task() -> resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse:
                channel = self._channel_manager.get_channel_from_state_type_name(
                    self._task_id.state_type, self._task_id.actor_id
                )

                stub = tasks_pb2_grpc.TasksStub(channel)

                try:
                    wait_for_task_response = await stub.Wait(
                        tasks_pb2.WaitRequest(task_id=self._task_id),
                        metadata=Headers(
                            service_name=state_type_to_service(self._task_id.state_type),
                            actor_id=self._task_id.actor_id,
                            # TODO(benh): will eventually be necessary to
                            # disambiguate between applications.
                            application_id=None,
                        ).to_grpc_metadata(),
                    )
                except grpc.aio.AioRpcError as error:
                    if error.code() == grpc.StatusCode.NOT_FOUND:
                        raise resemble.aio.aborted.SystemAborted(
                            resemble.v1alpha1.errors_pb2.UnknownTask()
                        ) from None

                    raise resemble.aio.aborted.SystemAborted.from_grpc_aio_rpc_error(
                        error
                    ) from None
                else:
                    response = resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse()

                    if (
                        wait_for_task_response.response.TypeName() !=
                        response.DESCRIPTOR.full_name
                    ):
                        raise resemble.aio.aborted.SystemAborted(
                            resemble.v1alpha1.errors_pb2.InvalidArgument(),
                            message=
                            f"task with UUID {str(uuid.UUID(bytes=self._task_id.task_uuid))} "
                            f"has a response of type '{wait_for_task_response.response.TypeName()}' "
                            "but expecting type 'resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse'; "
                            "are you waiting on a task of the correct method?",
                        ) from None

                    wait_for_task_response.response.Unpack(response)
                    return response

            return wait_for_task().__await__()

    DownTaskEffects: TypeAlias = Interface.DownTaskEffects

    class DownTaskAborted(resemble.aio.aborted.Aborted):


        Error = Union[
            resemble.aio.aborted.GrpcError,
            resemble.aio.aborted.ResembleError,
        ]

        METHOD_ERROR_TYPES: list[type[Error]] = [
        ]

        ERROR_TYPES: list[type[Error]] = (
            METHOD_ERROR_TYPES +
            resemble.aio.aborted.GRPC_ERROR_TYPES +
            resemble.aio.aborted.RESEMBLE_ERROR_TYPES
        )

        _error: Error
        _code: grpc.StatusCode
        _message: Optional[str]

        def __init__(
            self,
            error:  resemble.aio.aborted.GrpcError,
            *,
            message: Optional[str] = None,
            # Do not set this value when constructing in order to
            # raise. This is only used internally when constructing
            # from aborted calls.
            error_types: list[type[Error]] = (
                METHOD_ERROR_TYPES + resemble.aio.aborted.GRPC_ERROR_TYPES
            ),
        ):
            super().__init__()

            assert_type(error, error_types)

            self._error = error

            code = self.grpc_status_code_from_error(self._error)

            if code is None:
                # Must be a Resemble specific or declared method error.
                code = grpc.StatusCode.ABORTED

            self._code = code

            self._message = message

        @property
        def error(self) -> Error:
            return self._error

        @property
        def code(self) -> grpc.StatusCode:
            return self._code

        @property
        def message(self) -> Optional[str]:
            return self._message

        @classmethod
        def from_status(cls, status: status_pb2.Status):
            error = cls.error_from_google_rpc_status_details(
                status,
                cls.ERROR_TYPES,
            )

            message = status.message if len(status.message) > 0 else None

            if error is not None:
                return cls(error, message=message, error_types=cls.ERROR_TYPES)

            error = cls.error_from_google_rpc_status_code(status)

            assert error is not None

            # TODO(benh): also consider getting the type names from
            # `status.details` and including that in `message` to make
            # debugging easier.

            return cls(error, message=message)

        @classmethod
        def from_grpc_aio_rpc_error(cls, aio_rpc_error: grpc.aio.AioRpcError):
            return cls(
                cls.error_from_grpc_aio_rpc_error(aio_rpc_error),
                message=aio_rpc_error.details(),
            )

        @classmethod
        def is_declared_error(cls, message: google.protobuf.message.Message) -> bool:
            return False


    @classmethod
    async def Create(
        cls,
        __actor_id__: ActorId,
        __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
        __options__: Optional[resemble.aio.call.Options] = None,
    ) -> tuple[Application.WeakReference, resemble.cloud.v1alpha1.application.application_pb2.CreateResponse]:
        # TODO: mypy-protobuf declares that
        # `google.protobuf.message.Message` constructor arguments are
        # always non-None, when in reality they are optional.
        request = resemble.cloud.v1alpha1.application.application_pb2.CreateRequest(
        )
        idempotency: Optional[resemble.aio.idempotency.Idempotency] = None
        metadata: Optional[resemble.aio.types.GrpcMetadata] = None
        bearer_token: Optional[str] = None
        if __options__ is not None:
            if __options__.idempotency_key is not None:
                idempotency = Idempotency(key=__options__.idempotency_key)
            elif __options__.idempotency_alias is not None:
                idempotency = Idempotency(alias=__options__.idempotency_alias)
            if __options__.metadata is not None:
                metadata = __options__.metadata
            if __options__.bearer_token is not None:
                bearer_token = __options__.bearer_token

        reference = cls.lookup(__actor_id__, bearer_token=bearer_token)
        stub = reference._writer(__context_or_workflow__)
        return (
            reference,
            await stub.Create(
                request,
                idempotency=idempotency,
                metadata=metadata,
                bearer_token=bearer_token,
            )
        )


    class WeakReference:

        def __init__(
            self,
            actor_id: str,
            *,
            bearer_token: Optional[str] = None,
        ):
            resemble.aio.call.validate_ascii(
                actor_id,
                'actor_id',
                MAX_ACTOR_ID_LENGTH,
                error_type=InvalidActorIdError,
                illegal_characters='\x00\x01',
            )
            self._actor_id = actor_id
            self._reader_stub: Optional[ApplicationReaderStub] = None
            self._writer_stub: Optional[ApplicationWriterStub] = None
            self._workflow_stub: Optional[ApplicationWorkflowStub] = None
            self._tasks_stub: Optional[ApplicationTasksStub] = None
            self._bearer_token = bearer_token

        def _reader(
            self,
            context_or_workflow: ReaderContext | WriterContext | TransactionContext | WorkflowContext | Workflow,
        ) -> ApplicationReaderStub:
            if self._reader_stub is None:
                self._reader_stub = ApplicationReaderStub(
                    context_or_workflow=context_or_workflow,
                    actor_id=self._actor_id,
                    bearer_token=self._bearer_token,
                )
            assert self._reader_stub is not None
            assert self._reader_stub._idempotency_manager == context_or_workflow
            return self._reader_stub

        def _writer(
            self,
            context_or_workflow: TransactionContext | WorkflowContext | Workflow,
        ) -> ApplicationWriterStub:
            if self._writer_stub is None:
                self._writer_stub = ApplicationWriterStub(
                    context_or_workflow=context_or_workflow,
                    actor_id=self._actor_id,
                    bearer_token=self._bearer_token,
                )
            assert self._writer_stub is not None
            if self._writer_stub._idempotency_manager != context_or_workflow:
                raise MixedContextsError(
                    "This `WeakReference` for `Application` with ID "
                    f"'{self._actor_id}' has previously been used by a "
                    "different `Context` or `Workflow`. That is not allowed. "
                    "Instead create a new `WeakReference` for every `Context` "
                    "and `Workflow`, by calling "
                    f"`Application.lookup('{self._actor_id}')`."
                )
            return self._writer_stub

        def _workflow(
            self,
            context_or_workflow: TransactionContext | WorkflowContext | Workflow,
        ) -> ApplicationWorkflowStub:
            if self._workflow_stub is None:
                self._workflow_stub = ApplicationWorkflowStub(
                    context_or_workflow=context_or_workflow,
                    actor_id=self._actor_id,
                    bearer_token=self._bearer_token,
                )
            assert self._workflow_stub is not None
            assert self._workflow_stub._idempotency_manager == context_or_workflow
            return self._workflow_stub

        def _tasks(
            self,
            context_or_workflow: TransactionContext | WorkflowContext | Workflow,
        ) -> ApplicationTasksStub:
            if self._tasks_stub is None:
                self._tasks_stub = ApplicationTasksStub(
                    context_or_workflow=context_or_workflow,
                    actor_id=self._actor_id,
                    bearer_token=self._bearer_token,
                )
            assert self._tasks_stub is not None
            assert self._tasks_stub._idempotency_manager == context_or_workflow
            return self._tasks_stub

        class _Reactively:

            def __init__(
                self,
                *,
                service_name: ServiceName,
                actor_id: ActorId,
                bearer_token: Optional[str] = None,
            ):
                self._service_name = service_name
                self._actor_id = actor_id
                self._bearer_token = bearer_token


        def reactively(self):
            return Application.WeakReference._Reactively(
                service_name=ServiceName('resemble.cloud.v1alpha1.application.ApplicationInterface'),
                actor_id=self._actor_id,
                bearer_token=self._bearer_token,
            )

        class _Idempotently:

            def __init__(
                self,
                *,
                weak_reference: Application.WeakReference,
                alias: Optional[str],
                key: Optional[str],
            ):
                self._weak_reference = weak_reference
                self._alias = alias
                self._key = key

            def schedule(
                self,
                *,
                when: Optional[datetime | timedelta] = None,
            ) -> Application.WeakReference._Schedule:
                return Application.WeakReference._Schedule(
                    self._weak_reference._tasks,
                    when=when,
                    idempotency_alias=self._alias,
                    idempotency_key=self._key,
                )

            async def Up(
                self,
                __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
                __options__: resemble.aio.call.Options = resemble.aio.call.Options(),
                *,
                container_image_name: Optional[str] = None,
            ) -> resemble.cloud.v1alpha1.application.application_pb2.UpResponse:
                if __options__.idempotency_key is not None:
                    raise RuntimeError(
                        'Found redundant idempotency key in `Options`'
                    )

                if __options__.idempotency_alias is not None:
                    raise RuntimeError(
                        'Found redundant idempotency alias in `Options`'
                    )

                if self._alias is not None:
                    assert self._key is None
                    __options__ = dataclasses.replace(
                        __options__,
                        idempotency_alias=self._alias,
                    )
                elif self._key is not None:
                    assert self._alias is None
                    __options__ = dataclasses.replace(
                        __options__,
                        idempotency_key=self._key,
                    )

                return await self._weak_reference.Up(
                    __context_or_workflow__,
                    __options__,
                    container_image_name=container_image_name,
                )

            async def UpTask(
                self,
                __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
                __options__: resemble.aio.call.Options = resemble.aio.call.Options(),
                *,
                container_image_name: Optional[str] = None,
            ) -> resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse:
                if __options__.idempotency_key is not None:
                    raise RuntimeError(
                        'Found redundant idempotency key in `Options`'
                    )

                if __options__.idempotency_alias is not None:
                    raise RuntimeError(
                        'Found redundant idempotency alias in `Options`'
                    )

                if self._alias is not None:
                    assert self._key is None
                    __options__ = dataclasses.replace(
                        __options__,
                        idempotency_alias=self._alias,
                    )
                elif self._key is not None:
                    assert self._alias is None
                    __options__ = dataclasses.replace(
                        __options__,
                        idempotency_key=self._key,
                    )

                return await self._weak_reference.UpTask(
                    __context_or_workflow__,
                    __options__,
                    container_image_name=container_image_name,
                )

            async def Down(
                self,
                __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
                __options__: resemble.aio.call.Options = resemble.aio.call.Options(),
            ) -> resemble.cloud.v1alpha1.application.application_pb2.DownResponse:
                if __options__.idempotency_key is not None:
                    raise RuntimeError(
                        'Found redundant idempotency key in `Options`'
                    )

                if __options__.idempotency_alias is not None:
                    raise RuntimeError(
                        'Found redundant idempotency alias in `Options`'
                    )

                if self._alias is not None:
                    assert self._key is None
                    __options__ = dataclasses.replace(
                        __options__,
                        idempotency_alias=self._alias,
                    )
                elif self._key is not None:
                    assert self._alias is None
                    __options__ = dataclasses.replace(
                        __options__,
                        idempotency_key=self._key,
                    )

                return await self._weak_reference.Down(
                    __context_or_workflow__,
                    __options__,
                )

            async def DownTask(
                self,
                __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
                __options__: resemble.aio.call.Options = resemble.aio.call.Options(),
            ) -> resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse:
                if __options__.idempotency_key is not None:
                    raise RuntimeError(
                        'Found redundant idempotency key in `Options`'
                    )

                if __options__.idempotency_alias is not None:
                    raise RuntimeError(
                        'Found redundant idempotency alias in `Options`'
                    )

                if self._alias is not None:
                    assert self._key is None
                    __options__ = dataclasses.replace(
                        __options__,
                        idempotency_alias=self._alias,
                    )
                elif self._key is not None:
                    assert self._alias is None
                    __options__ = dataclasses.replace(
                        __options__,
                        idempotency_key=self._key,
                    )

                return await self._weak_reference.DownTask(
                    __context_or_workflow__,
                    __options__,
                )


        def idempotently(
            self,
            alias: Optional[str] = None,
            *,
            key: Optional[str] = None,
        ) -> Application.WeakReference._Idempotently:
            if (
                (alias is None and key is None) or
                (alias is not None and key is not None)
            ):
                raise RuntimeError(
                    'Exactly one of the positional argument `alias` '
                    'or the keyword argument `key` should be specified; '
                    f'see {resemble.settings.DOCS_BASE_URL}/docs/model/safety_correctness/idempotency '
                    'for more information'
                )

            return Application.WeakReference._Idempotently(
                weak_reference=self, alias=alias, key=key
            )

        class _Schedule:

            def __init__(
                self,
                tasks: Callable[[TransactionContext | WorkflowContext | Workflow], ApplicationTasksStub],
                *,
                when: Optional[datetime | timedelta] = None,
                idempotency_alias: Optional[str] = None,
                idempotency_key: Optional[str] = None,
            ) -> None:
                self._tasks = tasks
                self._when = when
                self._idempotency_alias = idempotency_alias
                self._idempotency_key = idempotency_key

            # Application callable tasks:
            async def Up(
                self,
                __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
                __options__: Optional[resemble.aio.call.Options] = None,
                *,
                container_image_name: Optional[str] = None,
            ) -> Application.UpFuture:
                if container_image_name is not None and not isinstance(
                    container_image_name,
                    str,
                ):
                    raise TypeError(
                        f"Can not construct protobuf message of type "
                        f"'resemble.cloud.v1alpha1.application.application_pb2.UpRequest': field 'container_image_name' is not "
                        f"of required type 'str'"
                    )
                # TODO: mypy-protobuf declares that
                # `google.protobuf.message.Message` constructor arguments are
                # always non-None, when in reality they are optional.
                request = resemble.cloud.v1alpha1.application.application_pb2.UpRequest(
                    container_image_name=container_image_name,  # type: ignore[arg-type]
                )

                schedule: Optional[datetime] = (datetime.now() + self._when) if isinstance(
                    self._when, timedelta
                ) else self._when

                metadata: Optional[resemble.aio.types.GrpcMetadata] = None
                idempotency: Optional[resemble.aio.idempotency.Idempotency] = None
                bearer_token: Optional[str] = None

                if __options__ is not None:
                    if __options__.idempotency_key is not None:
                        if (
                            self._idempotency_key is not None or
                            self._idempotency_alias is not None
                        ):
                            raise RuntimeError(
                                'Found redundant idempotency key in `Options`'
                            )
                        idempotency = Idempotency(key=__options__.idempotency_key)
                    elif __options__.idempotency_alias is not None:
                        if (
                            self._idempotency_key is not None or
                            self._idempotency_alias is not None
                        ):
                            raise RuntimeError(
                                'Found redundant idempotency alias in `Options`'
                            )
                        idempotency = Idempotency(alias=__options__.idempotency_alias)
                    if __options__.metadata is not None:
                        metadata = __options__.metadata
                    if __options__.bearer_token is not None:
                        bearer_token = __options__.bearer_token

                if self._idempotency_key is not None:
                    assert self._idempotency_alias is None
                    assert idempotency is None
                    idempotency = Idempotency(key=self._idempotency_key)
                elif self._idempotency_alias is not None:
                    assert self._idempotency_key is None
                    assert idempotency is None
                    idempotency = Idempotency(alias=self._idempotency_alias)

                # Add scheduling information to the metadata.
                metadata = (
                    (resemble.aio.headers.TASK_SCHEDULE,
                    schedule.isoformat() if schedule else ''),
                ) + (metadata or tuple())

                return Application.UpFuture(
                    __context_or_workflow__,
                    task_id=await self._tasks(__context_or_workflow__).Up(
                        request,
                        idempotency=idempotency,
                        metadata=metadata,
                        bearer_token=bearer_token,
                    )
                )

            async def UpTask(
                self,
                __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
                __options__: Optional[resemble.aio.call.Options] = None,
                *,
                container_image_name: Optional[str] = None,
            ) -> Application.UpTaskFuture:
                if container_image_name is not None and not isinstance(
                    container_image_name,
                    str,
                ):
                    raise TypeError(
                        f"Can not construct protobuf message of type "
                        f"'resemble.cloud.v1alpha1.application.application_pb2.UpRequest': field 'container_image_name' is not "
                        f"of required type 'str'"
                    )
                # TODO: mypy-protobuf declares that
                # `google.protobuf.message.Message` constructor arguments are
                # always non-None, when in reality they are optional.
                request = resemble.cloud.v1alpha1.application.application_pb2.UpRequest(
                    container_image_name=container_image_name,  # type: ignore[arg-type]
                )

                schedule: Optional[datetime] = (datetime.now() + self._when) if isinstance(
                    self._when, timedelta
                ) else self._when

                metadata: Optional[resemble.aio.types.GrpcMetadata] = None
                idempotency: Optional[resemble.aio.idempotency.Idempotency] = None
                bearer_token: Optional[str] = None

                if __options__ is not None:
                    if __options__.idempotency_key is not None:
                        if (
                            self._idempotency_key is not None or
                            self._idempotency_alias is not None
                        ):
                            raise RuntimeError(
                                'Found redundant idempotency key in `Options`'
                            )
                        idempotency = Idempotency(key=__options__.idempotency_key)
                    elif __options__.idempotency_alias is not None:
                        if (
                            self._idempotency_key is not None or
                            self._idempotency_alias is not None
                        ):
                            raise RuntimeError(
                                'Found redundant idempotency alias in `Options`'
                            )
                        idempotency = Idempotency(alias=__options__.idempotency_alias)
                    if __options__.metadata is not None:
                        metadata = __options__.metadata
                    if __options__.bearer_token is not None:
                        bearer_token = __options__.bearer_token

                if self._idempotency_key is not None:
                    assert self._idempotency_alias is None
                    assert idempotency is None
                    idempotency = Idempotency(key=self._idempotency_key)
                elif self._idempotency_alias is not None:
                    assert self._idempotency_key is None
                    assert idempotency is None
                    idempotency = Idempotency(alias=self._idempotency_alias)

                # Add scheduling information to the metadata.
                metadata = (
                    (resemble.aio.headers.TASK_SCHEDULE,
                    schedule.isoformat() if schedule else ''),
                ) + (metadata or tuple())

                return Application.UpTaskFuture(
                    __context_or_workflow__,
                    task_id=await self._tasks(__context_or_workflow__).UpTask(
                        request,
                        idempotency=idempotency,
                        metadata=metadata,
                        bearer_token=bearer_token,
                    )
                )

            async def Down(
                self,
                __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
                __options__: Optional[resemble.aio.call.Options] = None,
            ) -> Application.DownFuture:
                # TODO: mypy-protobuf declares that
                # `google.protobuf.message.Message` constructor arguments are
                # always non-None, when in reality they are optional.
                request = resemble.cloud.v1alpha1.application.application_pb2.DownRequest(
                )

                schedule: Optional[datetime] = (datetime.now() + self._when) if isinstance(
                    self._when, timedelta
                ) else self._when

                metadata: Optional[resemble.aio.types.GrpcMetadata] = None
                idempotency: Optional[resemble.aio.idempotency.Idempotency] = None
                bearer_token: Optional[str] = None

                if __options__ is not None:
                    if __options__.idempotency_key is not None:
                        if (
                            self._idempotency_key is not None or
                            self._idempotency_alias is not None
                        ):
                            raise RuntimeError(
                                'Found redundant idempotency key in `Options`'
                            )
                        idempotency = Idempotency(key=__options__.idempotency_key)
                    elif __options__.idempotency_alias is not None:
                        if (
                            self._idempotency_key is not None or
                            self._idempotency_alias is not None
                        ):
                            raise RuntimeError(
                                'Found redundant idempotency alias in `Options`'
                            )
                        idempotency = Idempotency(alias=__options__.idempotency_alias)
                    if __options__.metadata is not None:
                        metadata = __options__.metadata
                    if __options__.bearer_token is not None:
                        bearer_token = __options__.bearer_token

                if self._idempotency_key is not None:
                    assert self._idempotency_alias is None
                    assert idempotency is None
                    idempotency = Idempotency(key=self._idempotency_key)
                elif self._idempotency_alias is not None:
                    assert self._idempotency_key is None
                    assert idempotency is None
                    idempotency = Idempotency(alias=self._idempotency_alias)

                # Add scheduling information to the metadata.
                metadata = (
                    (resemble.aio.headers.TASK_SCHEDULE,
                    schedule.isoformat() if schedule else ''),
                ) + (metadata or tuple())

                return Application.DownFuture(
                    __context_or_workflow__,
                    task_id=await self._tasks(__context_or_workflow__).Down(
                        request,
                        idempotency=idempotency,
                        metadata=metadata,
                        bearer_token=bearer_token,
                    )
                )

            async def DownTask(
                self,
                __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
                __options__: Optional[resemble.aio.call.Options] = None,
            ) -> Application.DownTaskFuture:
                # TODO: mypy-protobuf declares that
                # `google.protobuf.message.Message` constructor arguments are
                # always non-None, when in reality they are optional.
                request = resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest(
                )

                schedule: Optional[datetime] = (datetime.now() + self._when) if isinstance(
                    self._when, timedelta
                ) else self._when

                metadata: Optional[resemble.aio.types.GrpcMetadata] = None
                idempotency: Optional[resemble.aio.idempotency.Idempotency] = None
                bearer_token: Optional[str] = None

                if __options__ is not None:
                    if __options__.idempotency_key is not None:
                        if (
                            self._idempotency_key is not None or
                            self._idempotency_alias is not None
                        ):
                            raise RuntimeError(
                                'Found redundant idempotency key in `Options`'
                            )
                        idempotency = Idempotency(key=__options__.idempotency_key)
                    elif __options__.idempotency_alias is not None:
                        if (
                            self._idempotency_key is not None or
                            self._idempotency_alias is not None
                        ):
                            raise RuntimeError(
                                'Found redundant idempotency alias in `Options`'
                            )
                        idempotency = Idempotency(alias=__options__.idempotency_alias)
                    if __options__.metadata is not None:
                        metadata = __options__.metadata
                    if __options__.bearer_token is not None:
                        bearer_token = __options__.bearer_token

                if self._idempotency_key is not None:
                    assert self._idempotency_alias is None
                    assert idempotency is None
                    idempotency = Idempotency(key=self._idempotency_key)
                elif self._idempotency_alias is not None:
                    assert self._idempotency_key is None
                    assert idempotency is None
                    idempotency = Idempotency(alias=self._idempotency_alias)

                # Add scheduling information to the metadata.
                metadata = (
                    (resemble.aio.headers.TASK_SCHEDULE,
                    schedule.isoformat() if schedule else ''),
                ) + (metadata or tuple())

                return Application.DownTaskFuture(
                    __context_or_workflow__,
                    task_id=await self._tasks(__context_or_workflow__).DownTask(
                        request,
                        idempotency=idempotency,
                        metadata=metadata,
                        bearer_token=bearer_token,
                    )
                )


        def schedule(
            self,
            *,
            when: Optional[datetime | timedelta] = None,
        ) -> Application.WeakReference._Schedule:
            return Application.WeakReference._Schedule(
                self._tasks, when=when
            )

        # Application specific methods:
        async def Up(
            self,
            __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
            __options__: Optional[resemble.aio.call.Options] = None,
            *,
            container_image_name: Optional[str] = None,
        ) -> resemble.cloud.v1alpha1.application.application_pb2.UpResponse:
            if container_image_name is not None and not isinstance(
                container_image_name,
                str,
            ):
                raise TypeError(
                    f"Can not construct protobuf message of type "
                    f"'resemble.cloud.v1alpha1.application.application_pb2.UpRequest': field 'container_image_name' is not "
                    f"of required type 'str'"
                )
            # TODO: mypy-protobuf declares that
            # `google.protobuf.message.Message` constructor arguments are
            # always non-None, when in reality they are optional.
            request = resemble.cloud.v1alpha1.application.application_pb2.UpRequest(
                container_image_name=container_image_name,  # type: ignore[arg-type]
            )
            idempotency: Optional[resemble.aio.idempotency.Idempotency] = None
            metadata: Optional[resemble.aio.types.GrpcMetadata] = None
            bearer_token: Optional[str] = None
            if __options__ is not None:
                if __options__.idempotency_key is not None:
                    idempotency = Idempotency(key=__options__.idempotency_key)
                elif __options__.idempotency_alias is not None:
                    idempotency = Idempotency(alias=__options__.idempotency_alias)
                if __options__.metadata is not None:
                    metadata = __options__.metadata
                if __options__.bearer_token is not None:
                    bearer_token = __options__.bearer_token

            return await self._writer(__context_or_workflow__).Up(
                request,
                idempotency=idempotency,
                metadata=metadata,
                bearer_token=bearer_token,
            )

        async def UpTask(
            self,
            __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
            __options__: Optional[resemble.aio.call.Options] = None,
            *,
            container_image_name: Optional[str] = None,
        ) -> resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse:
            if container_image_name is not None and not isinstance(
                container_image_name,
                str,
            ):
                raise TypeError(
                    f"Can not construct protobuf message of type "
                    f"'resemble.cloud.v1alpha1.application.application_pb2.UpRequest': field 'container_image_name' is not "
                    f"of required type 'str'"
                )
            # TODO: mypy-protobuf declares that
            # `google.protobuf.message.Message` constructor arguments are
            # always non-None, when in reality they are optional.
            request = resemble.cloud.v1alpha1.application.application_pb2.UpRequest(
                container_image_name=container_image_name,  # type: ignore[arg-type]
            )
            idempotency: Optional[resemble.aio.idempotency.Idempotency] = None
            metadata: Optional[resemble.aio.types.GrpcMetadata] = None
            bearer_token: Optional[str] = None
            if __options__ is not None:
                if __options__.idempotency_key is not None:
                    idempotency = Idempotency(key=__options__.idempotency_key)
                elif __options__.idempotency_alias is not None:
                    idempotency = Idempotency(alias=__options__.idempotency_alias)
                if __options__.metadata is not None:
                    metadata = __options__.metadata
                if __options__.bearer_token is not None:
                    bearer_token = __options__.bearer_token

            return await self._writer(__context_or_workflow__).UpTask(
                request,
                idempotency=idempotency,
                metadata=metadata,
                bearer_token=bearer_token,
            )

        async def Down(
            self,
            __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
            __options__: Optional[resemble.aio.call.Options] = None,
        ) -> resemble.cloud.v1alpha1.application.application_pb2.DownResponse:
            # TODO: mypy-protobuf declares that
            # `google.protobuf.message.Message` constructor arguments are
            # always non-None, when in reality they are optional.
            request = resemble.cloud.v1alpha1.application.application_pb2.DownRequest(
            )
            idempotency: Optional[resemble.aio.idempotency.Idempotency] = None
            metadata: Optional[resemble.aio.types.GrpcMetadata] = None
            bearer_token: Optional[str] = None
            if __options__ is not None:
                if __options__.idempotency_key is not None:
                    idempotency = Idempotency(key=__options__.idempotency_key)
                elif __options__.idempotency_alias is not None:
                    idempotency = Idempotency(alias=__options__.idempotency_alias)
                if __options__.metadata is not None:
                    metadata = __options__.metadata
                if __options__.bearer_token is not None:
                    bearer_token = __options__.bearer_token

            return await self._writer(__context_or_workflow__).Down(
                request,
                idempotency=idempotency,
                metadata=metadata,
                bearer_token=bearer_token,
            )

        async def DownTask(
            self,
            __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
            __options__: Optional[resemble.aio.call.Options] = None,
        ) -> resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse:
            # TODO: mypy-protobuf declares that
            # `google.protobuf.message.Message` constructor arguments are
            # always non-None, when in reality they are optional.
            request = resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest(
            )
            idempotency: Optional[resemble.aio.idempotency.Idempotency] = None
            metadata: Optional[resemble.aio.types.GrpcMetadata] = None
            bearer_token: Optional[str] = None
            if __options__ is not None:
                if __options__.idempotency_key is not None:
                    idempotency = Idempotency(key=__options__.idempotency_key)
                elif __options__.idempotency_alias is not None:
                    idempotency = Idempotency(alias=__options__.idempotency_alias)
                if __options__.metadata is not None:
                    metadata = __options__.metadata
                if __options__.bearer_token is not None:
                    bearer_token = __options__.bearer_token

            return await self._writer(__context_or_workflow__).DownTask(
                request,
                idempotency=idempotency,
                metadata=metadata,
                bearer_token=bearer_token,
            )


    @classmethod
    def lookup(
        cls,
        actor_id: str,
        *,
        bearer_token: Optional[str] = None,
    ) -> Application.WeakReference:
        return Application.WeakReference(
            actor_id, bearer_token=bearer_token
        )

    class _Idempotently:

        def __init__(self, *, alias: Optional[str], key: Optional[str]):
            self._alias = alias
            self._key = key

        async def Create(
            self,
            __actor_id__: ActorId,
            __context_or_workflow__: TransactionContext | WorkflowContext | Workflow,
            __options__: resemble.aio.call.Options = resemble.aio.call.Options(),
        ) -> tuple[Application.WeakReference, resemble.cloud.v1alpha1.application.application_pb2.CreateResponse]:
            if __options__.idempotency_key is not None:
                raise RuntimeError(
                    'Found redundant idempotency key in `Options`'
                )

            if __options__.idempotency_alias is not None:
                raise RuntimeError(
                    'Found redundant idempotency alias in `Options`'
                )

            if self._alias is not None:
                assert self._key is None
                __options__ = dataclasses.replace(
                    __options__,
                    idempotency_alias=self._alias,
                )
            elif self._key is not None:
                assert self._alias is None
                __options__ = dataclasses.replace(
                    __options__,
                    idempotency_key=self._key,
                )

            return await Application.Create(
                __actor_id__,
                __context_or_workflow__,
                __options__,
            )


    @classmethod
    def idempotently(
        cls,
        alias: Optional[str] = None,
        *,
        key: Optional[str] = None,
    ) -> Application._Idempotently:
        if (
            (alias is None and key is None) or
            (alias is not None and key is not None)
        ):
            raise RuntimeError(
                'Exactly one of the positional argument `alias` '
                'or the keyword argument `key` should be specified; '
                f'see {resemble.settings.DOCS_BASE_URL}/docs/model/safety_correctness/idempotency '
                'for more information'
            )

        return Application._Idempotently(alias=alias, key=key)


class ApplicationServicerNodeAdaptor(Application.Interface):

    def __init__(self):
        # TODO: See https://github.com/reboot-dev/respect/issues/2339
        self._js_servicer_reference = self._construct_js_servicer()  # type: ignore[attr-defined]

    # Application specific methods:
    async def Create(
        self,
        context: WriterContext,
        request: resemble.cloud.v1alpha1.application.application_pb2.CreateRequest,
    ) -> Application.CreateEffects:

        json_request = google.protobuf.json_format.MessageToJson(request)

        # TODO: See https://github.com/reboot-dev/respect/issues/2339
        json_effects = await self._writer(  # type: ignore[attr-defined]
            self._js_servicer_reference,
            'Create',
            context,
            None,
            json_request,
        )

        effects = json.loads(json_effects)

        assert not hasattr(effects, 'tasks'), "JS tasks not yet implemented"

        return Application.CreateEffects(
            state=google.protobuf.json_format.ParseDict(
                effects['state'],
                resemble.cloud.v1alpha1.application.application_pb2.Application(),
            ),
            response=google.protobuf.json_format.ParseDict(
                effects['response'],
                resemble.cloud.v1alpha1.application.application_pb2.CreateResponse(),
            ),
        )

    async def Up(
        self,
        context: WriterContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
    ) -> Application.UpEffects:
        json_state = google.protobuf.json_format.MessageToJson(state)

        json_request = google.protobuf.json_format.MessageToJson(request)

        # TODO: See https://github.com/reboot-dev/respect/issues/2339
        json_effects = await self._writer(  # type: ignore[attr-defined]
            self._js_servicer_reference,
            'Up',
            context,
            json_state,
            json_request,
        )

        effects = json.loads(json_effects)

        assert not hasattr(effects, 'tasks'), "JS tasks not yet implemented"

        return Application.UpEffects(
            state=google.protobuf.json_format.ParseDict(
                effects['state'],
                resemble.cloud.v1alpha1.application.application_pb2.Application(),
            ),
            response=google.protobuf.json_format.ParseDict(
                effects['response'],
                resemble.cloud.v1alpha1.application.application_pb2.UpResponse(),
            ),
        )

    async def UpTask(
        self,
        context: WriterContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.UpRequest,
    ) -> Application.UpTaskEffects:
        json_state = google.protobuf.json_format.MessageToJson(state)

        json_request = google.protobuf.json_format.MessageToJson(request)

        # TODO: See https://github.com/reboot-dev/respect/issues/2339
        json_effects = await self._writer(  # type: ignore[attr-defined]
            self._js_servicer_reference,
            'UpTask',
            context,
            json_state,
            json_request,
        )

        effects = json.loads(json_effects)

        assert not hasattr(effects, 'tasks'), "JS tasks not yet implemented"

        return Application.UpTaskEffects(
            state=google.protobuf.json_format.ParseDict(
                effects['state'],
                resemble.cloud.v1alpha1.application.application_pb2.Application(),
            ),
            response=google.protobuf.json_format.ParseDict(
                effects['response'],
                resemble.cloud.v1alpha1.application.application_pb2.UpTaskResponse(),
            ),
        )

    async def Down(
        self,
        context: WriterContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownRequest,
    ) -> Application.DownEffects:
        json_state = google.protobuf.json_format.MessageToJson(state)

        json_request = google.protobuf.json_format.MessageToJson(request)

        # TODO: See https://github.com/reboot-dev/respect/issues/2339
        json_effects = await self._writer(  # type: ignore[attr-defined]
            self._js_servicer_reference,
            'Down',
            context,
            json_state,
            json_request,
        )

        effects = json.loads(json_effects)

        assert not hasattr(effects, 'tasks'), "JS tasks not yet implemented"

        return Application.DownEffects(
            state=google.protobuf.json_format.ParseDict(
                effects['state'],
                resemble.cloud.v1alpha1.application.application_pb2.Application(),
            ),
            response=google.protobuf.json_format.ParseDict(
                effects['response'],
                resemble.cloud.v1alpha1.application.application_pb2.DownResponse(),
            ),
        )

    async def DownTask(
        self,
        context: WriterContext,
        state: resemble.cloud.v1alpha1.application.application_pb2.Application,
        request: resemble.cloud.v1alpha1.application.application_pb2.DownTaskRequest,
    ) -> Application.DownTaskEffects:
        json_state = google.protobuf.json_format.MessageToJson(state)

        json_request = google.protobuf.json_format.MessageToJson(request)

        # TODO: See https://github.com/reboot-dev/respect/issues/2339
        json_effects = await self._writer(  # type: ignore[attr-defined]
            self._js_servicer_reference,
            'DownTask',
            context,
            json_state,
            json_request,
        )

        effects = json.loads(json_effects)

        assert not hasattr(effects, 'tasks'), "JS tasks not yet implemented"

        return Application.DownTaskEffects(
            state=google.protobuf.json_format.ParseDict(
                effects['state'],
                resemble.cloud.v1alpha1.application.application_pb2.Application(),
            ),
            response=google.protobuf.json_format.ParseDict(
                effects['response'],
                resemble.cloud.v1alpha1.application.application_pb2.DownTaskResponse(),
            ),
        )



class ApplicationNodeAdaptor(Application.WeakReference):

    async def _reader(  # type: ignore[override]
        self,
        method: str,
        context: ReaderContext | WriterContext | TransactionContext | WorkflowContext | Workflow,
        request_type: type[google.protobuf.message.Message],
        json_request: str,
    ) -> str:
        request = request_type()

        google.protobuf.json_format.Parse(json_request, request)

        response = await getattr(super()._reader(context), method)(request)

        return google.protobuf.json_format.MessageToJson(response)

    async def _writer(  # type: ignore[override]
        self,
        method: str,
        context: TransactionContext | WorkflowContext | Workflow,
        request_type: type[google.protobuf.message.Message],
        json_request: str,
    ) -> str:
        request = request_type()

        google.protobuf.json_format.Parse(json_request, request)

        response = await getattr(super()._writer(context), method)(request)

        return google.protobuf.json_format.MessageToJson(response)

# yapf: enable
