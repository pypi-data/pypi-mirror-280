import abc
from .Documentation import Documentable as Documentable, Documentation as Documentation
from .Lint import ValidationProblem as ValidationProblem, ValidationTree as ValidationTree
from .utils import ANSI_SQL_NamedObject as ANSI_SQL_NamedObject, is_valid_sql_identifier as is_valid_sql_identifier
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from datasurface.md.Policy import DataClassification as DataClassification, DataClassificationPolicy as DataClassificationPolicy
from enum import Enum
from typing import OrderedDict

def handleUnsupportedObjectsToJson(obj: object) -> str: ...

class DataType(ABC, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    @abstractmethod
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...
    @abstractmethod
    def lint(self, vTree: ValidationTree) -> None: ...
    def to_json(self) -> str: ...

class BoundedDataType(DataType):
    maxSize: Incomplete
    def __init__(self, maxSize: int | None) -> None: ...
    def lint(self, vTree: ValidationTree) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class ArrayType(BoundedDataType):
    dataType: Incomplete
    def __init__(self, maxSize: int | None, type: DataType) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class MapType(DataType):
    keyType: Incomplete
    valueType: Incomplete
    def __init__(self, key_type: DataType, value_type: DataType) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...
    def lint(self, vTree: ValidationTree): ...

class StructType(DataType):
    fields: Incomplete
    def __init__(self, fields: OrderedDict[str, DataType]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...
    def lint(self, vTree: ValidationTree): ...

class TextDataType(BoundedDataType):
    collationString: Incomplete
    def __init__(self, maxSize: int | None, collationString: str | None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class NumericDataType(DataType, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...
    def __eq__(self, __value: object) -> bool: ...

class SignedOrNot(Enum):
    SIGNED: int
    UNSIGNED: int

class FixedIntegerDataType(NumericDataType):
    sizeInBits: Incomplete
    isSigned: Incomplete
    def __init__(self, sizeInBits: int, isSigned: SignedOrNot) -> None: ...
    def lint(self, vTree: ValidationTree) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class TinyInt(FixedIntegerDataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class SmallInt(FixedIntegerDataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class Integer(FixedIntegerDataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class BigInt(FixedIntegerDataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class NonFiniteBehavior(Enum):
    IEEE754: int
    NanOnly: int

class FloatNanEncoding(Enum):
    IEEE: int
    AllOnes: int
    NegativeZero: int

class CustomFloat(NumericDataType):
    sizeInBits: Incomplete
    maxExponent: Incomplete
    minExponent: Incomplete
    precision: Incomplete
    nonFiniteBehavior: Incomplete
    nanEncoding: Incomplete
    def __init__(self, maxExponent: int, minExponent: int, precision: int, sizeInBits: int, nonFiniteBehavior: NonFiniteBehavior = ..., nanEncoding: FloatNanEncoding = ...) -> None: ...
    def lint(self, vTree: ValidationTree) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isRepresentableBy(self, other: CustomFloat) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class IEEE16(CustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class IEEE32(CustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class Float(IEEE32):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class IEEE64(CustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class Double(IEEE64):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class SimpleCustomFloat(CustomFloat):
    def __init__(self, maxExponent: int, minExponent: int, precision: int, sizeInBits: int, nonFiniteBehavior: NonFiniteBehavior = ..., nanEncoding: FloatNanEncoding = ...) -> None: ...

class IEEE128(SimpleCustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class IEEE256(SimpleCustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class FP8_E4M3(SimpleCustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class FP6_E2M3(SimpleCustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class FP6_E3M2(SimpleCustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class FP4_E2M1(SimpleCustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class FP8_E5M2(SimpleCustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class FP8_E5M2FNUZ(SimpleCustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class FP8_E4M3FNUZ(SimpleCustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class FP8_E8M0(SimpleCustomFloat):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class MicroScaling_CustomFloat(NumericDataType, metaclass=abc.ABCMeta):
    batchSize: Incomplete
    scaleType: Incomplete
    elementType: Incomplete
    def __init__(self, batchSize: int, scaleType: type[CustomFloat], elementType: type[CustomFloat]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class MXFP8_E4M3(MicroScaling_CustomFloat, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class MXFP8_E5M2(MicroScaling_CustomFloat, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class MXFP6_E2M3(MicroScaling_CustomFloat, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class MXFP6_E3M2(MicroScaling_CustomFloat, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class MXFP4_E2M1(MicroScaling_CustomFloat, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class Decimal(BoundedDataType):
    precision: Incomplete
    def __init__(self, maxSize: int, precision: int) -> None: ...
    def lint(self, vTree: ValidationTree) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class TimeZone:
    timeZone: Incomplete
    def __init__(self, timeZone: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class TemporalDataType(DataType, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, vTree: ValidationTree) -> None: ...

class Timestamp(TemporalDataType):
    timeZone: Incomplete
    def __init__(self, tz: TimeZone = ...) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class Date(TemporalDataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class Interval(TemporalDataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class UniCodeType(TextDataType):
    def __init__(self, maxSize: int | None, collationString: str | None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class NonUnicodeString(TextDataType):
    def __init__(self, maxSize: int | None, collationString: str | None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class VarChar(NonUnicodeString):
    def __init__(self, maxSize: int | None = None, collationString: str | None = None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class NVarChar(UniCodeType):
    def __init__(self, maxSize: int | None = None, collationString: str | None = None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class String(NVarChar):
    def __init__(self, maxSize: int | None = None, collationString: str | None = None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

def strForFixedSizeString(clsName: str, maxSize: int, collationString: str | None) -> str: ...

class Char(NonUnicodeString):
    def __init__(self, maxSize: int = 1, collationString: str | None = None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class NChar(UniCodeType):
    def __init__(self, maxSize: int = 1, collationString: str | None = None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class Boolean(DataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...
    def lint(self, vTree: ValidationTree) -> None: ...

class Variant(BoundedDataType):
    def __init__(self, maxSize: int | None = None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class Binary(BoundedDataType):
    def __init__(self, maxSize: int | None = None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class Vector(ArrayType):
    def __init__(self, dimensions: int) -> None: ...
    def lint(self, vTree: ValidationTree) -> None: ...

class NullableStatus(Enum):
    NOT_NULLABLE: int
    NULLABLE: int

class PrimaryKeyStatus(Enum):
    NOT_PK: int
    PK: int

DEFAULT_primaryKey: PrimaryKeyStatus
DEFAULT_nullable: NullableStatus

class DDLColumn(ANSI_SQL_NamedObject, Documentable):
    type: Incomplete
    primaryKey: Incomplete
    classification: Incomplete
    nullable: Incomplete
    def __init__(self, name: str, dataType: DataType, *args: NullableStatus | DataClassification | PrimaryKeyStatus | Documentation) -> None: ...
    documentation: Incomplete
    def add(self, *args: NullableStatus | DataClassification | PrimaryKeyStatus | Documentation) -> None: ...
    def __eq__(self, o: object) -> bool: ...
    def checkForBackwardsCompatibility(self, other: object, vTree: ValidationTree) -> bool: ...
    def lint(self, tree: ValidationTree) -> None: ...

class AttributeList:
    colNames: Incomplete
    def __init__(self, colNames: list[str]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, tree: ValidationTree) -> None: ...

class PrimaryKeyList(AttributeList):
    def __init__(self, colNames: list[str]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class PartitionKeyList(AttributeList):
    def __init__(self, colNames: list[str]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class NotBackwardsCompatible(ValidationProblem):
    def __init__(self, problem: str) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

class Schema(ABC, Documentable, metaclass=abc.ABCMeta):
    primaryKeyColumns: Incomplete
    ingestionPartitionColumns: Incomplete
    def __init__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    @abstractmethod
    def getHubSchema(self) -> Schema: ...
    @abstractmethod
    def checkForBackwardsCompatibility(self, other: Schema, vTree: ValidationTree) -> bool: ...
    @abstractmethod
    def checkClassificationsAreOnly(self, verifier: DataClassificationPolicy) -> bool: ...
    @abstractmethod
    def hasDataClassifications(self) -> bool: ...
    @abstractmethod
    def lint(self, tree: ValidationTree) -> None: ...

class DDLTable(Schema):
    columns: Incomplete
    def __init__(self, *args: DDLColumn | PrimaryKeyList | PartitionKeyList | Documentation) -> None: ...
    def hasDataClassifications(self) -> bool: ...
    def checkClassificationsAreOnly(self, verifier: DataClassificationPolicy) -> bool: ...
    primaryKeyColumns: Incomplete
    ingestionPartitionColumns: Incomplete
    documentation: Incomplete
    def add(self, *args: DDLColumn | PrimaryKeyList | PartitionKeyList | Documentation): ...
    def calculateKeys(self) -> None: ...
    def getHubSchema(self) -> Schema: ...
    def getColumnByName(self, name: str) -> DDLColumn | None: ...
    def __eq__(self, o: object) -> bool: ...
    def checkForBackwardsCompatibility(self, other: Schema, vTree: ValidationTree) -> bool: ...
    def lint(self, tree: ValidationTree) -> None: ...
