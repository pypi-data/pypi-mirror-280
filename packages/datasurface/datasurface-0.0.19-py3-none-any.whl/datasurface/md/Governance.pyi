import abc
from .Documentation import Documentable as Documentable, Documentation as Documentation
from .Exceptions import AttributeAlreadySetException as AttributeAlreadySetException, ObjectAlreadyExistsException as ObjectAlreadyExistsException, ObjectDoesntExistException as ObjectDoesntExistException, UnknownArgumentException as UnknownArgumentException
from .Lint import AttributeNotSet as AttributeNotSet, ConstraintViolation as ConstraintViolation, DataTransformerMissing as DataTransformerMissing, DuplicateObject as DuplicateObject, NameHasBadSynthax as NameHasBadSynthax, NameMustBeSQLIdentifier as NameMustBeSQLIdentifier, ObjectIsDeprecated as ObjectIsDeprecated, ObjectMissing as ObjectMissing, ObjectNotCompatibleWithPolicy as ObjectNotCompatibleWithPolicy, ObjectWrongType as ObjectWrongType, ProblemSeverity as ProblemSeverity, ProductionDatastoreMustHaveClassifications as ProductionDatastoreMustHaveClassifications, UnauthorizedAttributeChange as UnauthorizedAttributeChange, UnknownChangeSource as UnknownChangeSource, UnknownObjectReference as UnknownObjectReference, ValidationProblem as ValidationProblem, ValidationTree as ValidationTree
from .Schema import DataClassification as DataClassification, DataClassificationPolicy as DataClassificationPolicy, Schema as Schema
from .utils import ANSI_SQL_NamedObject as ANSI_SQL_NamedObject, is_valid_hostname_or_ip as is_valid_hostname_or_ip, is_valid_sql_identifier as is_valid_sql_identifier, validate_cron_string as validate_cron_string
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datasurface.md.GitOps import GitControlledObject as GitControlledObject, Repository as Repository
from datasurface.md.Policy import AllowDisallowPolicy as AllowDisallowPolicy, Policy as Policy
from datetime import timedelta
from enum import Enum
from typing import Callable, Generic, Sequence, TypeVar

class ProductionStatus(Enum):
    PRODUCTION: int
    NOT_PRODUCTION: int

class DeprecationStatus(Enum):
    NOT_DEPRECATED: int
    DEPRECATED: int

class DeprecationInfo(Documentable):
    status: Incomplete
    def __init__(self, status: DeprecationStatus, reason: Documentation | None = None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

def cyclic_safe_eq(a: object, b: object, visited: set[object]) -> bool: ...

class GenericKey(ABC):
    def __hash__(self) -> int: ...

class EcosystemKey(GenericKey):
    ecoName: Incomplete
    def __init__(self, ecoName: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class GovernanceZoneKey(EcosystemKey):
    gzName: Incomplete
    def __init__(self, e: EcosystemKey, gz: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class StoragePolicyKey(GovernanceZoneKey):
    policyName: Incomplete
    def __init__(self, gz: GovernanceZoneKey, policyName: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class InfrastructureVendorKey(EcosystemKey):
    ivName: Incomplete
    def __init__(self, eco: EcosystemKey, iv: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class InfraLocationKey(InfrastructureVendorKey):
    locationPath: Incomplete
    def __init__(self, iv: InfrastructureVendorKey, loc: list[str]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class TeamDeclarationKey(GovernanceZoneKey):
    tdName: Incomplete
    def __init__(self, gz: GovernanceZoneKey, td: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class WorkspaceKey(TeamDeclarationKey):
    name: Incomplete
    def __init__(self, tdKey: TeamDeclarationKey, name: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class DatastoreKey(TeamDeclarationKey):
    dsName: Incomplete
    def __init__(self, td: TeamDeclarationKey, ds: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class PolicyMandatedRule(Enum):
    MANDATED_WITHIN_ZONE: int
    INDIVIDUALLY_MANDATED: int

class StoragePolicy(Policy['DataContainer']):
    mandatory: Incomplete
    key: Incomplete
    deprecationStatus: Incomplete
    def __init__(self, name: str, isMandatory: PolicyMandatedRule, doc: Documentation | None, deprecationStatus: DeprecationInfo) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def setGovernanceZone(self, gz: GovernanceZone) -> None: ...
    def isCompatible(self, obj: DataContainer) -> bool: ...

class StoragePolicyAllowAnyContainer(StoragePolicy):
    def __init__(self, name: str, isMandatory: PolicyMandatedRule, doc: Documentation | None = None, deprecationStatus: DeprecationInfo = ...) -> None: ...
    def isCompatible(self, obj: DataContainer) -> bool: ...
    def __eq__(self, __value: object) -> bool: ...

class InfrastructureLocation(Documentable):
    name: Incomplete
    key: Incomplete
    locations: Incomplete
    def __init__(self, name: str, *args: Documentation | InfrastructureLocation) -> None: ...
    def __hash__(self) -> int: ...
    def lint(self, tree: ValidationTree): ...
    def setParentLocation(self, parent: InfraLocationKey) -> None: ...
    documentation: Incomplete
    def add(self, *args: Documentation | InfrastructureLocation) -> None: ...
    def addLocation(self, loc: InfrastructureLocation): ...
    def __eq__(self, __value: object) -> bool: ...
    def getEveryChildLocation(self) -> set['InfrastructureLocation']: ...
    def containsLocation(self, child: InfrastructureLocation) -> bool: ...
    def getLocationOrThrow(self, locationName: str) -> InfrastructureLocation: ...
    def getLocation(self, locationName: str) -> InfrastructureLocation | None: ...
    def findLocationUsingKey(self, locationPath: list[str]) -> InfrastructureLocation | None: ...

class CloudVendor(Enum):
    AWS: int
    AZURE: int
    GCP: int
    IBM: int
    ORACLE: int
    ALIBABA: int
    AWS_CHINA: int
    TEN_CENT: int
    HUAWEI: int
    AZURE_CHINA: int
    PRIVATE: int

class InfrastructureVendor(Documentable):
    name: Incomplete
    key: Incomplete
    locations: Incomplete
    hardCloudVendor: Incomplete
    def __init__(self, name: str, *args: InfrastructureLocation | Documentation | CloudVendor) -> None: ...
    def __hash__(self) -> int: ...
    def setEcosystem(self, eco: Ecosystem) -> None: ...
    documentation: Incomplete
    def add(self, *args: InfrastructureLocation | Documentation | CloudVendor) -> None: ...
    def addLocation(self, loc: InfrastructureLocation): ...
    def __eq__(self, __value: object) -> bool: ...
    def getLocationOrThrow(self, locationName: str) -> InfrastructureLocation: ...
    def getLocation(self, locationName: str) -> InfrastructureLocation | None: ...
    def findLocationUsingKey(self, locationPath: list[str]) -> InfrastructureLocation | None: ...
    def lint(self, tree: ValidationTree): ...

class InfraStructureVendorPolicy(AllowDisallowPolicy[InfrastructureVendor]):
    def __init__(self, name: str, doc: Documentation, allowed: set[InfrastructureVendor] | None = None, notAllowed: set[InfrastructureVendor] | None = None) -> None: ...
    def __eq__(self, v: object) -> bool: ...
    def __hash__(self) -> int: ...

class InfraHardVendorPolicy(AllowDisallowPolicy[CloudVendor]):
    def __init__(self, name: str, doc: Documentation, allowed: set[CloudVendor] | None = None, notAllowed: set[CloudVendor] | None = None) -> None: ...
    def __eq__(self, v: object) -> bool: ...
    def __hash__(self) -> int: ...

class InfraStructureLocationPolicy(AllowDisallowPolicy[InfrastructureLocation]):
    def __init__(self, name: str, doc: Documentation, allowed: set[InfrastructureLocation] | None = None, notAllowed: set[InfrastructureLocation] | None = None) -> None: ...
    def __eq__(self, v: object) -> bool: ...
    def __hash__(self) -> int: ...

class DataPlatformPolicy(AllowDisallowPolicy['DataPlatform']):
    def __init__(self, name: str, doc: Documentation | None, allowed: set['DataPlatform'] | None = None, notAllowed: set['DataPlatform'] | None = None) -> None: ...
    def __eq__(self, v: object) -> bool: ...
    def __hash__(self) -> int: ...

class EncryptionSystem:
    name: Incomplete
    keyContainer: Incomplete
    hasThirdPartySuperUser: bool
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class SchemaProjector(ABC, metaclass=abc.ABCMeta):
    dataset: Incomplete
    def __init__(self, dataset: Dataset) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    @abstractmethod
    def computeSchema(self) -> Schema | None: ...

class DefaultSchemaProjector(SchemaProjector):
    def __init__(self, dataset: Dataset) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def computeSchema(self) -> Schema | None: ...

class CaseSensitiveEnum(Enum):
    CASE_SENSITIVE: int
    CASE_INSENSITIVE: int

class DataContainerNamingMapper(metaclass=abc.ABCMeta):
    maxLen: Incomplete
    caseSensitive: Incomplete
    allowQuotes: Incomplete
    def __init__(self, maxLen: int = 255, caseSensitive: CaseSensitiveEnum = ..., allowQuotes: str | None = None) -> None: ...
    def formatIdentifier(self, s: str) -> str: ...
    def truncateIdentifier(self, s: str, maxLen: int) -> str: ...
    @abstractmethod
    def mapRawDatasetName(self, w: Workspace, dsg: DatasetGroup, store: Datastore, ds: Dataset) -> str: ...
    @abstractmethod
    def mapRawDatasetView(self, w: Workspace, dsg: DatasetGroup, store: Datastore, ds: Dataset) -> str: ...
    @abstractmethod
    def mapAttributeName(self, w: Workspace, dsg: DatasetGroup, store: Datastore, ds: Dataset, attributeName: str) -> str: ...

class DefaultDataContainerNamingMapper(DataContainerNamingMapper):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def mapRawDatasetName(self, w: Workspace, dsg: DatasetGroup, store: Datastore, ds: Dataset) -> str: ...
    def mapRawDatasetView(self, w: Workspace, dsg: DatasetGroup, store: Datastore, ds: Dataset) -> str: ...
    def mapAttributeName(self, w: Workspace, dsg: DatasetGroup, store: Datastore, ds: Dataset, attributeName: str) -> str: ...

class DataContainer(ABC, Documentable, metaclass=abc.ABCMeta):
    locations: Incomplete
    name: Incomplete
    serverSideEncryptionKeys: Incomplete
    clientSideEncryptionKeys: Incomplete
    isReadOnly: bool
    def __init__(self, name: str, *args: InfrastructureLocation | Documentation) -> None: ...
    documentation: Incomplete
    def add(self, *args: InfrastructureLocation | Documentation) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def getName(self) -> str: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...
    def __hash__(self) -> int: ...
    def areLocationsOwnedByTheseVendors(self, eco: Ecosystem, vendors: set[CloudVendor]) -> bool: ...
    def areAllLocationsInLocations(self, locations: set[InfrastructureLocation]) -> bool: ...
    @abstractmethod
    def projectDatasetSchema(self, dataset: Dataset) -> SchemaProjector: ...
    @abstractmethod
    def getNamingAdapter(self) -> DataContainerNamingMapper: ...

class SQLDatabase(DataContainer):
    databaseName: Incomplete
    def __init__(self, name: str, location: InfrastructureLocation, databaseName: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...
    def projectDatasetSchema(self, dataset: Dataset) -> SchemaProjector: ...
    def getNamingAdapter(self) -> DataContainerNamingMapper: ...

class URLSQLDatabase(SQLDatabase):
    url: Incomplete
    def __init__(self, name: str, location: InfrastructureLocation, url: str, databaseName: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class HostPortSQLDatabase(SQLDatabase):
    host: Incomplete
    port: Incomplete
    def __init__(self, name: str, location: InfrastructureLocation, host: str, port: int, databaseName: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...

class ObjectStorage(DataContainer, metaclass=abc.ABCMeta):
    endPointURI: Incomplete
    bucketName: Incomplete
    prefix: Incomplete
    def __init__(self, name: str, loc: InfrastructureLocation, endPointURI: str | None, bucketName: str, prefix: str | None) -> None: ...
    def projectDatasetSchema(self, dataset: Dataset) -> SchemaProjector: ...

class Dataset(ANSI_SQL_NamedObject, Documentable):
    originalSchema: Incomplete
    policies: Incomplete
    dataClassificationOverride: Incomplete
    deprecationStatus: Incomplete
    def __init__(self, name: str, *args: Schema | StoragePolicy | Documentation | DeprecationInfo | DataClassification) -> None: ...
    documentation: Incomplete
    def add(self, *args: Schema | StoragePolicy | Documentation | DeprecationInfo | DataClassification) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, store: Datastore, tree: ValidationTree) -> None: ...
    def checkClassificationsAreOnly(self, verifier: DataClassificationPolicy) -> bool: ...
    def checkForBackwardsCompatibility(self, other: object, vTree: ValidationTree) -> bool: ...
    def hasClassifications(self) -> bool: ...

class Credential(ABC, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...

class FileSecretCredential(Credential):
    secretFilePath: Incomplete
    def __init__(self, filePath: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...

class UserPasswordCredential(Credential):
    username: Incomplete
    password: Incomplete
    def __init__(self, username: str, password: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...

class CertificateCredential(Credential):
    certificate: Incomplete
    key: Incomplete
    authIsInSecure: Incomplete
    def __init__(self, certificate: str | None, key: str, authIsInSecure: bool) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...

class ClearTextCredential(UserPasswordCredential):
    def __init__(self, username: str, password: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...

class PyOdbcSourceInfo(SQLDatabase):
    serverHost: Incomplete
    driver: Incomplete
    connectionStringTemplate: Incomplete
    def __init__(self, name: str, loc: InfrastructureLocation, serverHost: str, databaseName: str, driver: str, connectionStringTemplate: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...
    def projectDatasetSchema(self, dataset: Dataset) -> SchemaProjector: ...

class CaptureType(Enum):
    SNAPSHOT: int
    INCREMENTAL: int

class IngestionConsistencyType(Enum):
    SINGLE_DATASET: int
    MULTI_DATASET: int

class StepTrigger(ABC, metaclass=abc.ABCMeta):
    name: Incomplete
    def __init__(self, name: str) -> None: ...
    def __eq__(self, o: object) -> bool: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, tree: ValidationTree) -> None: ...

class CronTrigger(StepTrigger):
    cron: Incomplete
    def __init__(self, name: str, cron: str) -> None: ...
    def __eq__(self, o: object) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, tree: ValidationTree) -> None: ...

class CaptureMetaData(ABC, metaclass=abc.ABCMeta):
    singleOrMultiDatasetIngestion: Incomplete
    stepTrigger: Incomplete
    dataContainer: Incomplete
    def __init__(self, *args: StepTrigger | DataContainer | IngestionConsistencyType) -> None: ...
    def add(self, *args: StepTrigger | DataContainer | IngestionConsistencyType) -> None: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, d: Datastore, tree: ValidationTree) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class DataTransformerOutput(CaptureMetaData):
    workSpaceName: Incomplete
    singleOrMultiDatasetIngestion: Incomplete
    def __init__(self, workSpaceName: str) -> None: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, d: Datastore, tree: ValidationTree) -> None: ...
    def __eq__(self, o: object) -> bool: ...

class IngestionMetadata(CaptureMetaData, metaclass=abc.ABCMeta):
    credential: Incomplete
    def __init__(self, *args: DataContainer | Credential | StepTrigger | IngestionConsistencyType) -> None: ...
    def add(self, *args: Credential | DataContainer | StepTrigger | IngestionConsistencyType) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, d: Datastore, tree: ValidationTree) -> None: ...

class CDCCaptureIngestion(IngestionMetadata):
    def __init__(self, dc: DataContainer, *args: Credential | StepTrigger | IngestionConsistencyType) -> None: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, d: Datastore, tree: ValidationTree) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class SQLPullIngestion(IngestionMetadata):
    variableNames: Incomplete
    snapshotSQL: Incomplete
    deltaSQL: Incomplete
    def __init__(self, dc: DataContainer, *args: Credential | StepTrigger | IngestionConsistencyType) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, d: Datastore, tree: ValidationTree) -> None: ...

class Datastore(ANSI_SQL_NamedObject, Documentable):
    datasets: Incomplete
    key: Incomplete
    cmd: Incomplete
    productionStatus: Incomplete
    deprecationStatus: Incomplete
    def __init__(self, name: str, *args: Dataset | CaptureMetaData | Documentation | ProductionStatus | DeprecationInfo) -> None: ...
    def setTeam(self, tdKey: TeamDeclarationKey): ...
    documentation: Incomplete
    def add(self, *args: Dataset | CaptureMetaData | Documentation | ProductionStatus | DeprecationInfo) -> None: ...
    def isDatasetDeprecated(self, dataset: Dataset) -> bool: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, storeTree: ValidationTree) -> None: ...
    def checkForBackwardsCompatibility(self, other: object, vTree: ValidationTree) -> bool: ...

class TeamCacheEntry:
    team: Incomplete
    declaration: Incomplete
    def __init__(self, t: Team, td: TeamDeclaration) -> None: ...

class WorkspaceCacheEntry:
    workspace: Incomplete
    team: Incomplete
    def __init__(self, w: Workspace, t: Team) -> None: ...

class DatastoreCacheEntry:
    datastore: Incomplete
    team: Incomplete
    def __init__(self, d: Datastore, t: Team) -> None: ...

class DependentWorkspaces:
    workspace: Incomplete
    dependencies: Incomplete
    def __init__(self, workSpace: Workspace) -> None: ...
    def addDependency(self, dep: DependentWorkspaces) -> None: ...
    def flatten(self) -> set['Workspace']: ...
    def __hash__(self) -> int: ...
    def __eq__(self, __value: object) -> bool: ...

class DefaultDataPlatform:
    defaultPlatform: Incomplete
    def __init__(self, p: DataPlatform) -> None: ...

class Ecosystem(GitControlledObject):
    def createGZone(self, name: str, repo: Repository) -> GovernanceZone: ...
    name: Incomplete
    key: Incomplete
    zones: Incomplete
    vendors: Incomplete
    dataPlatforms: Incomplete
    defaultDataPlatform: Incomplete
    def __init__(self, name: str, repo: Repository, *args: DataPlatform | Documentation | DefaultDataPlatform | InfrastructureVendor | GovernanceZoneDeclaration) -> None: ...
    datastoreCache: Incomplete
    workSpaceCache: Incomplete
    teamCache: Incomplete
    def resetCaches(self) -> None: ...
    documentation: Incomplete
    def add(self, *args: DataPlatform | DefaultDataPlatform | Documentation | InfrastructureVendor | GovernanceZoneDeclaration) -> None: ...
    def getDefaultDataPlatform(self) -> DataPlatform: ...
    def getVendor(self, name: str) -> InfrastructureVendor | None: ...
    def checkDataPlatformExists(self, d: DataPlatform) -> bool: ...
    def getVendorOrThrow(self, name: str) -> InfrastructureVendor: ...
    def getDataPlatform(self, name: str) -> DataPlatform | None: ...
    def getDataPlatformOrThrow(self, name: str) -> DataPlatform: ...
    def getLocation(self, vendorName: str, locKey: list[str]) -> InfrastructureLocation | None: ...
    def getLocationOrThrow(self, vendorName: str, locKey: list[str]) -> InfrastructureLocation: ...
    def getAllChildLocations(self, vendorName: str, locKey: list[str]) -> set[InfrastructureLocation]: ...
    def cache_addTeam(self, td: TeamDeclaration, t: Team): ...
    def cache_addWorkspace(self, team: Team, work: Workspace): ...
    def cache_addDatastore(self, store: Datastore, t: Team): ...
    def cache_getWorkspaceOrThrow(self, work: str) -> WorkspaceCacheEntry: ...
    def cache_getDatastoreOrThrow(self, store: str) -> DatastoreCacheEntry: ...
    def cache_getDataset(self, storeName: str, datasetName: str) -> Dataset | None: ...
    def lintAndHydrateCaches(self) -> ValidationTree: ...
    def calculateDependenciesForDatastore(self, storeName: str, wsVisitedSet: set[str] = ...) -> Sequence[DependentWorkspaces]: ...
    def checkIfChangesAreAuthorized(self, proposed: GitControlledObject, changeSource: Repository, vTree: ValidationTree) -> None: ...
    def __eq__(self, proposed: object) -> bool: ...
    def areTopLevelChangesAuthorized(self, proposed: GitControlledObject, changeSource: Repository, tree: ValidationTree) -> bool: ...
    def getZone(self, gz: str) -> GovernanceZone | None: ...
    def getZoneOrThrow(self, gz: str) -> GovernanceZone: ...
    def getTeam(self, gz: str, teamName: str) -> Team | None: ...
    def getTeamOrThrow(self, gz: str, teamName: str) -> Team: ...
    def checkIfChangesAreBackwardsCompatibleWith(self, originEco: Ecosystem, vTree: ValidationTree) -> None: ...
    def checkIfChangeSourceIsUsed(self, changeSource: Repository, tree: ValidationTree) -> None: ...
    def checkIfChangesCanBeMerged(self, proposed: Ecosystem, source: Repository) -> ValidationTree: ...

class Team(GitControlledObject):
    name: Incomplete
    workspaces: Incomplete
    dataStores: Incomplete
    def __init__(self, name: str, repo: Repository, *args: Datastore | Workspace | Documentation) -> None: ...
    documentation: Incomplete
    def add(self, *args: Datastore | Workspace | Documentation) -> None: ...
    def addStore(self, store: Datastore): ...
    def addWorkspace(self, w: Workspace): ...
    def __eq__(self, __value: object) -> bool: ...
    def getStoreOrThrow(self, storeName: str) -> Datastore: ...
    def areTopLevelChangesAuthorized(self, proposed: GitControlledObject, changeSource: Repository, tree: ValidationTree) -> bool: ...
    def checkIfChangesAreAuthorized(self, proposed: GitControlledObject, changeSource: Repository, vTree: ValidationTree) -> None: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, td: TeamDeclaration, teamTree: ValidationTree) -> None: ...
    def checkForBackwardsCompatibility(self, originTeam: Team, vTree: ValidationTree): ...

class NamedObjectAuthorization:
    name: Incomplete
    owningRepo: Incomplete
    def __init__(self, name: str, owningRepo: Repository) -> None: ...
    def lint(self, tree: ValidationTree): ...
    def __eq__(self, __value: object) -> bool: ...
G = TypeVar('G', bound=GitControlledObject)
N = TypeVar('N', bound=NamedObjectAuthorization)

class AuthorizedObjectManager(GitControlledObject, Generic[G, N]):
    name: Incomplete
    authorizedNames: Incomplete
    authorizedObjects: Incomplete
    factory: Incomplete
    def __init__(self, name: str, factory: Callable[[str, Repository], G], owningRepo: Repository) -> None: ...
    def getNumObjects(self) -> int: ...
    def addAuthorization(self, t: N): ...
    def defineAllObjects(self) -> None: ...
    def getObject(self, name: str) -> G | None: ...
    def __eq__(self, __value: object) -> bool: ...
    def areTopLevelChangesAuthorized(self, proposed: GitControlledObject, changeSource: Repository, tree: ValidationTree) -> bool: ...
    def checkIfChangesAreAuthorized(self, proposed: GitControlledObject, changeSource: Repository, vTree: ValidationTree) -> None: ...
    def removeAuthorization(self, name: str) -> N | None: ...
    def removeDefinition(self, name: str) -> G | None: ...
    def lint(self, tree: ValidationTree): ...

class TeamDeclaration(NamedObjectAuthorization):
    authRepo: Incomplete
    key: Incomplete
    def __init__(self, name: str, authRepo: Repository) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def setGovernanceZone(self, gz: GovernanceZone) -> None: ...

class GovernanceZoneDeclaration(NamedObjectAuthorization):
    key: Incomplete
    def __init__(self, name: str, authRepo: Repository) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class GovernanceZone(GitControlledObject):
    name: Incomplete
    key: Incomplete
    teams: Incomplete
    storagePolicies: Incomplete
    classificationPolicies: Incomplete
    vendorPolicies: Incomplete
    hardVendorPolicies: Incomplete
    locationPolicies: Incomplete
    dataplatformPolicies: Incomplete
    def __init__(self, name: str, ownerRepo: Repository, *args: InfraStructureLocationPolicy | InfraStructureVendorPolicy | StoragePolicy | DataClassificationPolicy | TeamDeclaration | Documentation | DataPlatformPolicy | InfraHardVendorPolicy) -> None: ...
    def setEcosystem(self, eco: Ecosystem) -> None: ...
    def checkLocationIsAllowed(self, eco: Ecosystem, loc: InfrastructureLocation, tree: ValidationTree): ...
    documentation: Incomplete
    def add(self, *args: InfraStructureVendorPolicy | InfraStructureLocationPolicy | StoragePolicy | DataClassificationPolicy | TeamDeclaration | DataPlatformPolicy | Documentation | InfraHardVendorPolicy) -> None: ...
    def getTeam(self, name: str) -> Team | None: ...
    def getTeamOrThrow(self, name: str) -> Team: ...
    def __eq__(self, __value: object) -> bool: ...
    def areTopLevelChangesAuthorized(self, proposed: GitControlledObject, changeSource: Repository, tree: ValidationTree) -> bool: ...
    def checkIfChangesAreAuthorized(self, proposed: GitControlledObject, changeSource: Repository, vTree: ValidationTree) -> None: ...
    def lint(self, eco: Ecosystem, govTree: ValidationTree) -> None: ...
    def checkForBackwardsCompatiblity(self, originZone: GovernanceZone, tree: ValidationTree): ...
    def getDatasetStoragePolicies(self, dataset: Dataset) -> Sequence[StoragePolicy]: ...

@dataclass
class WorkspaceEntitlement: ...
@dataclass
class EventSink: ...
@dataclass
class Deliverable: ...

class DockerContainer:
    name: Incomplete
    image: Incomplete
    version: Incomplete
    cmd: Incomplete
    def __init__(self, name: str, image: str, version: str, cmd: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class DataPlatformExecutor(ABC, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, tree: ValidationTree): ...

class DataPlatformCICDExecutor(DataPlatformExecutor):
    iacRepo: Incomplete
    def __init__(self, repo: Repository) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree): ...

class DataPlatform(ABC, Documentable, metaclass=abc.ABCMeta):
    name: Incomplete
    executor: Incomplete
    def __init__(self, name: str, doc: Documentation, executor: DataPlatformExecutor) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...
    @abstractmethod
    def getInternalDataContainers(self) -> set[DataContainer]: ...
    @abstractmethod
    def getSupportedVendors(self, eco: Ecosystem) -> set[CloudVendor]: ...
    @abstractmethod
    def isContainerSupported(self, eco: Ecosystem, dc: DataContainer) -> bool: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, tree: ValidationTree): ...
    @abstractmethod
    def createIaCRender(self, graph: PlatformPipelineGraph) -> IaCDataPlatformRenderer: ...

class DataLatency(Enum):
    SECONDS: int
    MINUTES: int
    HOURS: int
    DAYS: int

class DataRetentionPolicy(Enum):
    LIVE_ONLY: int
    FORENSIC: int
    LIVE_WITH_FORENSIC_HISTORY: int

class ConsumerRetentionRequirements:
    policy: Incomplete
    latency: Incomplete
    minRetentionTime: Incomplete
    regulator: Incomplete
    def __init__(self, r: DataRetentionPolicy, latency: DataLatency, regulator: str | None, minRetentionDurationIfNeeded: timedelta | None = None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class DataPlatformChooser(ABC, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    @abstractmethod
    def choooseDataPlatform(self, eco: Ecosystem) -> DataPlatform | None: ...

class FixedDataPlatform(DataPlatformChooser):
    fixedDataPlatform: Incomplete
    def __init__(self, dp: DataPlatform) -> None: ...
    def choooseDataPlatform(self, eco: Ecosystem) -> DataPlatform | None: ...
    def __eq__(self, __value: object) -> bool: ...

class WorkspacePlatformConfig(DataPlatformChooser):
    retention: Incomplete
    def __init__(self, hist: ConsumerRetentionRequirements) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def choooseDataPlatform(self, eco: Ecosystem) -> DataPlatform | None: ...

class WorkspaceFixedDataPlatform(DataPlatformChooser):
    dataPlatform: Incomplete
    def __init__(self, dp: DataPlatform) -> None: ...
    def __eq__(self, o: object) -> bool: ...
    def choooseDataPlatform(self, eco: Ecosystem) -> DataPlatform | None: ...

class DeprecationsAllowed(Enum):
    NEVER: int
    ALLOWED: int

class DatasetSink:
    storeName: Incomplete
    datasetName: Incomplete
    key: Incomplete
    deprecationsAllowed: Incomplete
    def __init__(self, storeName: str, datasetName: str, deprecationsAllowed: DeprecationsAllowed = ...) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...
    def lint(self, eco: Ecosystem, team: Team, ws: Workspace, tree: ValidationTree): ...

class DatasetGroup(ANSI_SQL_NamedObject, Documentable):
    platformMD: Incomplete
    sinks: Incomplete
    documentation: Incomplete
    def __init__(self, name: str, *args: DatasetSink | DataPlatformChooser | Documentation) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, team: Team, ws: Workspace, tree: ValidationTree): ...

class TransformerTrigger:
    name: Incomplete
    def __init__(self, name: str) -> None: ...
    def __eq__(self, o: object) -> bool: ...

class TimedTransformerTrigger(TransformerTrigger):
    trigger: Incomplete
    def __init__(self, name: str, transformerTrigger: StepTrigger) -> None: ...
    def __eq__(self, o: object) -> bool: ...

class CodeArtifact(ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...
    def __eq__(self, o: object) -> bool: ...

class PythonCodeArtifact(CodeArtifact):
    requirements: Incomplete
    envVars: Incomplete
    requiredVersion: Incomplete
    def __init__(self, requirements: list[str], envVars: dict[str, str], requiredVersion: str) -> None: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...
    def __eq__(self, o: object) -> bool: ...

class CodeExecutionEnvironment(ABC, metaclass=abc.ABCMeta):
    location: Incomplete
    def __init__(self, loc: InfrastructureLocation) -> None: ...
    def __eq__(self, o: object) -> bool: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...

class KubernetesEnvironment(CodeExecutionEnvironment):
    hostName: Incomplete
    credential: Incomplete
    def __init__(self, hostName: str, cred: Credential, loc: InfrastructureLocation) -> None: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree): ...

class DataTransformer(ANSI_SQL_NamedObject, Documentable):
    outputDatastore: Incomplete
    trigger: Incomplete
    code: Incomplete
    codeEnv: Incomplete
    documentation: Incomplete
    def __init__(self, name: str, store: Datastore, trigger: TransformerTrigger, code: CodeArtifact, codeEnv: CodeExecutionEnvironment, doc: Documentation | None = None) -> None: ...
    def lint(self, eco: Ecosystem, ws: Workspace, tree: ValidationTree): ...
    def __eq__(self, o: object) -> bool: ...

class Workspace(ANSI_SQL_NamedObject, Documentable):
    dsgs: Incomplete
    dataContainer: Incomplete
    productionStatus: Incomplete
    deprecationStatus: Incomplete
    dataTransformer: Incomplete
    classificationVerifier: Incomplete
    key: Incomplete
    def __init__(self, name: str, *args: DatasetGroup | DataContainer | Documentation | DataClassificationPolicy | ProductionStatus | DeprecationInfo | DataTransformer) -> None: ...
    def setTeam(self, key: TeamDeclarationKey): ...
    documentation: Incomplete
    def add(self, *args: DatasetGroup | DataContainer | Documentation | DataClassificationPolicy | ProductionStatus | DeprecationInfo | DataTransformer): ...
    def __hash__(self) -> int: ...
    def __eq__(self, __value: object) -> bool: ...
    def isDatastoreUsed(self, store: Datastore) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, tree: ValidationTree): ...

class PlatformStyle(Enum):
    OLTP: int
    OLAP: int
    COLUMNAR: int
    OBJECT: int

class PipelineNode:
    name: Incomplete
    platform: Incomplete
    leftHandNodes: Incomplete
    rightHandNodes: Incomplete
    def __init__(self, name: str, platform: DataPlatform) -> None: ...
    def __eq__(self, o: object) -> bool: ...
    def addRightHandNode(self, rhNode: PipelineNode): ...

class ExportNode(PipelineNode):
    dataContainer: Incomplete
    storeName: Incomplete
    datasetName: Incomplete
    def __init__(self, platform: DataPlatform, dataContainer: DataContainer, storeName: str, datasetName: str) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, o: object) -> bool: ...

class IngestionNode(PipelineNode):
    storeName: Incomplete
    captureTrigger: Incomplete
    def __init__(self, name: str, platform: DataPlatform, storeName: str, captureTrigger: StepTrigger | None) -> None: ...
    def __eq__(self, o: object) -> bool: ...

class IngestionMultiNode(IngestionNode):
    def __init__(self, platform: DataPlatform, storeName: str, captureTrigger: StepTrigger | None) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, o: object) -> bool: ...

class IngestionSingleNode(IngestionNode):
    datasetName: Incomplete
    def __init__(self, platform: DataPlatform, storeName: str, dataset: str, captureTrigger: StepTrigger | None) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, o: object) -> bool: ...

class TriggerNode(PipelineNode):
    workspace: Incomplete
    def __init__(self, w: Workspace, platform: DataPlatform) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, o: object) -> bool: ...

class DataTransformerNode(PipelineNode):
    workspace: Incomplete
    def __init__(self, ws: Workspace, platform: DataPlatform) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, o: object) -> bool: ...

class DSGRootNode:
    workspace: Incomplete
    dsg: Incomplete
    def __init__(self, w: Workspace, dsg: DatasetGroup) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, o: object) -> bool: ...

class PlatformPipelineGraph:
    platform: Incomplete
    eco: Incomplete
    workspaces: Incomplete
    roots: Incomplete
    dataContainerExports: Incomplete
    storesToIngest: Incomplete
    nodes: Incomplete
    def __init__(self, eco: Ecosystem, platform: DataPlatform) -> None: ...
    def generateGraph(self) -> None: ...
    def findExistingOrCreateStep(self, step: PipelineNode) -> PipelineNode: ...
    def createIngestionStep(self, storeName: str): ...
    def createIngestionStepForDataStore(self, store: Datastore, exportStep: ExportNode) -> PipelineNode: ...
    def createGraphForDataTransformer(self, dt: DataTransformerOutput, exportStep: ExportNode) -> None: ...
    def addExportToPriorIngestion(self, exportStep: ExportNode): ...
    def getLeftSideOfGraph(self) -> set[PipelineNode]: ...
    def getRightSideOfGraph(self) -> set[PipelineNode]: ...
    def checkNextStepsForStepType(self, filterStep: type[PipelineNode], targetStep: type[PipelineNode]) -> bool: ...
    def graphToText(self) -> str: ...
    def lint(self, tree: ValidationTree) -> None: ...

class EcosystemPipelineGraph:
    eco: Incomplete
    roots: Incomplete
    def __init__(self, eco: Ecosystem) -> None: ...
    def lint(self, tree: ValidationTree) -> None: ...

class IaCFragmentManager(ABC, Documentable, metaclass=abc.ABCMeta):
    name: Incomplete
    def __init__(self, name: str, doc: Documentation) -> None: ...
    @abstractmethod
    def preRender(self): ...
    @abstractmethod
    def postRender(self): ...
    @abstractmethod
    def addFragment(self, node: PipelineNode, fragment: str): ...

class CombineToStringFragmentManager(IaCFragmentManager, metaclass=abc.ABCMeta):
    fragments: Incomplete
    def __init__(self, name: str, doc: Documentation) -> None: ...
    def addFragment(self, node: PipelineNode, fragment: str): ...

def defaultPipelineNodeFileName(node: PipelineNode) -> str: ...

class FileBasedFragmentManager(IaCFragmentManager, metaclass=abc.ABCMeta):
    rootDir: Incomplete
    fnGetFileNameForNode: Incomplete
    def __init__(self, name: str, doc: Documentation, fnGetFileNameForNode: Callable[[PipelineNode], str]) -> None: ...
    def addFragment(self, node: PipelineNode, fragment: str): ...
    def addStaticFile(self, folder: str, name: str, fragment: str): ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class IaCDataPlatformRenderer(ABC, metaclass=abc.ABCMeta):
    executor: Incomplete
    graph: Incomplete
    def __init__(self, executor: DataPlatformExecutor, graph: PlatformPipelineGraph) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def renderIaC(self, fragments: IaCFragmentManager) -> IaCFragmentManager: ...
    @abstractmethod
    def renderIngestionSingle(self, ingestNode: IngestionSingleNode) -> str: ...
    @abstractmethod
    def renderIngestionMulti(self, ingestNode: IngestionMultiNode) -> str: ...
    @abstractmethod
    def renderExport(self, exportNode: ExportNode) -> str: ...
    @abstractmethod
    def renderTrigger(self, triggerNode: TriggerNode) -> str: ...
    @abstractmethod
    def renderDataTransformer(self, dtNode: DataTransformerNode) -> str: ...
    @abstractmethod
    def lintIngestionSingleNode(self, eco: Ecosystem, node: IngestionSingleNode, tree: ValidationTree) -> None: ...
    @abstractmethod
    def lintIngestionMultiNode(self, eco: Ecosystem, node: IngestionMultiNode, tree: ValidationTree) -> None: ...
    @abstractmethod
    def lintExportNode(self, eco: Ecosystem, node: ExportNode, tree: ValidationTree) -> None: ...
    @abstractmethod
    def lintTriggerNode(self, eco: Ecosystem, node: TriggerNode, tree: ValidationTree) -> None: ...
    @abstractmethod
    def lintDataTransformerNode(self, eco: Ecosystem, node: DataTransformerNode, tree: ValidationTree) -> None: ...
    def lintGraph(self, eco: Ecosystem, tree: ValidationTree): ...
    def getDataContainerForDatastore(self, storeName: str) -> DataContainer | None: ...
    def isDataContainerSupported(self, dc: DataContainer, allowedContainers: set[type[DataContainer]]) -> bool: ...

class IaCDataPlatformRendererShim(IaCDataPlatformRenderer):
    def __init__(self, executor: DataPlatformExecutor, graph: PlatformPipelineGraph) -> None: ...
    def renderIngestionSingle(self, ingestNode: IngestionSingleNode) -> str: ...
    def renderIngestionMulti(self, ingestNode: IngestionMultiNode) -> str: ...
    def renderExport(self, exportNode: ExportNode) -> str: ...
    def renderTrigger(self, triggerNode: TriggerNode) -> str: ...
    def renderDataTransformer(self, dtNode: DataTransformerNode) -> str: ...
    def lintIngestionSingleNode(self, eco: Ecosystem, node: IngestionSingleNode, tree: ValidationTree) -> None: ...
    def lintIngestionMultiNode(self, eco: Ecosystem, node: IngestionMultiNode, tree: ValidationTree) -> None: ...
    def lintExportNode(self, eco: Ecosystem, node: ExportNode, tree: ValidationTree) -> None: ...
    def lintTriggerNode(self, eco: Ecosystem, node: TriggerNode, tree: ValidationTree) -> None: ...
    def lintDataTransformerNode(self, eco: Ecosystem, node: DataTransformerNode, tree: ValidationTree) -> None: ...

class UnsupportedDataContainer(ValidationProblem):
    def __init__(self, dc: DataContainer) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...
