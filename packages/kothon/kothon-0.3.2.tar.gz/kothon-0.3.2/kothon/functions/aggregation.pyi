from .._utils.type_utils import AT as AT, CT as CT
from ..iterable.seq import Seq as Seq
from typing import Callable, Iterable, TypeVar, overload

T = TypeVar('T')
Key = TypeVar('Key')
Value = TypeVar('Value')

def to_list(sequence: Iterable[T]) -> list[T]: ...
def to_set(sequence: Iterable[T]) -> set[T]: ...
def to_frozenset(sequence: Iterable[T]) -> frozenset[T]: ...
@overload
def associate(fn: Callable[[T], tuple[Key, Value]], sequence: Iterable[T]) -> dict[Key, Value]: ...
@overload
def associate(fn: Callable[[T], tuple[Key, Value]]) -> Callable[[Iterable[T]], dict[Key, Value]]: ...
@overload
def associate_by(key_selector: Callable[[T], Key], sequence: Iterable[T]) -> dict[Key, T]: ...
@overload
def associate_by(key_selector: Callable[[T], Key]) -> Callable[[Iterable[T]], dict[Key, T]]: ...
@overload
def associate_with(value_selector: Callable[[T], Value], sequence: Iterable[T]) -> dict[T, Value]: ...
@overload
def associate_with(value_selector: Callable[[T], Value]) -> Callable[[Iterable[T]], dict[T, Value]]: ...
@overload
def group_by(key_selector: Callable[[T], Key], sequence: Iterable[T]) -> dict[Key, list[T]]: ...
@overload
def group_by(key_selector: Callable[[T], Key]) -> Callable[[Iterable[T]], dict[Key, list[T]]]: ...
@overload
def all_by(predicate: Callable[[T], bool], sequence: Iterable[T]) -> bool: ...
@overload
def all_by(predicate: Callable[[T], bool]) -> Callable[[Iterable[T]], bool]: ...
@overload
def none_by(predicate: Callable[[T], bool], sequence: Iterable[T]) -> bool: ...
@overload
def none_by(predicate: Callable[[T], bool]) -> Callable[[Iterable[T]], bool]: ...
@overload
def any_by(predicate: Callable[[T], bool], sequence: Iterable[T]) -> bool: ...
@overload
def any_by(predicate: Callable[[T], bool]) -> Callable[[Iterable[T]], bool]: ...
def max_or_none(sequence: Iterable[CT]) -> CT | None: ...
@overload
def max_by(selector: Callable[[T], CT], sequence: Iterable[T]) -> T: ...
@overload
def max_by(selector: Callable[[T], CT]) -> Callable[[Iterable[T]], T]: ...
@overload
def max_by_or_none(selector: Callable[[T], CT], sequence: Iterable[T]) -> T | None: ...
@overload
def max_by_or_none(selector: Callable[[T], CT]) -> Callable[[Iterable[T]], T | None]: ...
def min_or_none(sequence: Iterable[CT]) -> CT | None: ...
@overload
def min_by(selector: Callable[[T], CT], sequence: Iterable[T]) -> T: ...
@overload
def min_by(selector: Callable[[T], CT]) -> Callable[[Iterable[T]], T]: ...
@overload
def min_by_or_none(selector: Callable[[T], CT], sequence: Iterable[T]) -> T | None: ...
@overload
def min_by_or_none(selector: Callable[[T], CT]) -> Callable[[Iterable[T]], T | None]: ...
def single(sequence: Iterable[T]) -> T: ...
def single_or_none(sequence: Iterable[T]) -> T | None: ...
def first(sequence: Iterable[T]) -> T: ...
def first_or_none(sequence: Iterable[T]) -> T | None: ...
def last(sequence: Iterable[T]) -> T: ...
def last_or_none(sequence: Iterable[T]) -> T | None: ...
@overload
def reduce_or_none(operation: Callable[[T, T], T], sequence: Iterable[T]) -> T | None: ...
@overload
def reduce_or_none(operation: Callable[[T, T], T]) -> Callable[[Iterable[T]], T | None]: ...
def sum_or_none(sequence: Iterable[AT]) -> AT | None: ...
def join_to_string(separator: str = ', ', prefix: str = '', suffix: str = '') -> Callable[[Iterable[T]], str]: ...
