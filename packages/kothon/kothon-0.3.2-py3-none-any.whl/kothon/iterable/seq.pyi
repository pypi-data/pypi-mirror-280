import random
from .._utils.type_utils import AT as AT, CT as CT
from typing import Optional, Callable, Generic, Iterable, Iterator, Type, TypeVar

T = TypeVar('T')
R = TypeVar('R')
Key = TypeVar('Key')
Value = TypeVar('Value')

class Seq(Generic[T]):
    def __init__(self, iterable: Iterable[T]) -> None: ...
    def __iter__(self) -> Iterator[T]: ...
    def filter(self, predicate: Callable[[T], bool]) -> Seq[T]: ...
    def filter_not_none(self: "Seq[Optional[R]]") -> Seq[R]: ...
    def filter_is_instance(self, cls: Type[R]) -> Seq[R]: ...
    def map(self, fn: Callable[[T], R]) -> Seq[R]: ...
    def map_not_none(self, fn: Callable[[T], R | None]) -> Seq[R]: ...
    def flat_map(self, fn: Callable[[T], Iterable[R]]) -> Seq[R]: ...
    def flatten(self: "Seq[Iterable[R]]") -> Seq[R]: ...
    def associate(self, fn: Callable[[T], tuple[Key, Value]]) -> dict[Key, Value]: ...
    def associate_by(self, key_selector: Callable[[T], Key]) -> dict[Key, T]: ...
    def associate_with(self, value_selector: Callable[[T], Value]) -> dict[T, Value]: ...
    def group_by(self, key_selector: Callable[[T], Key]) -> dict[Key, list[T]]: ...
    def to_list(self) -> list[T]: ...
    def to_set(self) -> set[T]: ...
    def to_frozenset(self) -> frozenset[T]: ...
    def all(self, predicate: Callable[[T], bool] | None = None) -> bool: ...
    def none(self, predicate: Callable[[T], bool] | None = None) -> bool: ...
    def any(self, predicate: Callable[[T], bool] | None = None) -> bool: ...
    def max(self: "Seq[CT]") -> CT: ...
    def max_or_none(self: "Seq[CT]") -> CT | None: ...
    def max_by(self, selector: Callable[[T], CT]) -> T: ...
    def max_by_or_none(self, selector: Callable[[T], CT]) -> T | None: ...
    def min(self: "Seq[CT]") -> CT: ...
    def min_or_none(self: "Seq[CT]") -> CT | None: ...
    def min_by(self, selector: Callable[[T], CT]) -> T: ...
    def min_by_or_none(self, selector: Callable[[T], CT]) -> T | None: ...
    def single(self) -> T: ...
    def single_or_none(self) -> T | None: ...
    def first(self) -> T: ...
    def first_or_none(self) -> T | None: ...
    def last(self) -> T: ...
    def last_or_none(self) -> T | None: ...
    def drop(self, n: int) -> Seq[T]: ...
    def drop_while(self, predicate: Callable[[T], bool]) -> Seq[T]: ...
    def take(self, n: int) -> Seq[T]: ...
    def take_while(self, predicate: Callable[[T], bool]) -> Seq[T]: ...
    def sorted(self: "Seq[CT]") -> Seq[CT]: ...
    def sorted_by(self, key_func: Callable[[T], CT]) -> Seq[T]: ...
    def sorted_desc(self: "Seq[CT]") -> Seq[CT]: ...
    def sorted_by_desc(self, key_func: Callable[[T], CT]) -> Seq[T]: ...
    def chunked(self, size: int) -> Seq[list[T]]: ...
    def enumerate(self) -> Seq[tuple[int, T]]: ...
    def shuffled(self, rng: random.Random | None = None) -> Seq[T]: ...
    def reduce(self, operation: Callable[[T, T], T]) -> T: ...
    def reduce_or_none(self, operation: Callable[[T, T], T]) -> T | None: ...
    def sum(self: "Seq[AT]") -> AT: ...
    def sum_or_none(self: "Seq[AT]") -> AT | None: ...
    def distinct(self) -> Seq[T]: ...
    def distinct_by(self, key_selector: Callable[[T], R]) -> Seq[T]: ...
    def for_each(self, action: Callable[[T], None]) -> None: ...
    def join_to_string(self, separator: str = ', ', prefix: str = '', suffix: str = '') -> str: ...
    def partition(self, predicate: Callable[[T], bool]) -> tuple[list[T], list[T]]: ...
