import numpy as np

def increase_resolution(x_arr, t_arr, D, k, tmax):
    """
    Increase the resolution of a Wiener trajectory (t_arr, x_arr) from k-1 to k

    Parameters
    ----------
    x_arr : Array
        Positions of the Wiener trajectory arrays that were also previously generated by "increase_resolution". Must have length 2^(k-1)+1
    t_arr : Array
        Times of the Wiener trajectory arrays that were also previously generated by "increase_resolution". Must have length 2^(k-1)+1
    D : Float
        Diffusion constant
    k : Integer
        Desired resolution, this value must be pre-incremented outside of the function (i.e. x_arr and t_arr have a resolution k-1, and will return a resolution of k after this function)
    tmax : Float
        Maximum time considered, can also be a resetting time.

    Returns
    -------
    x_arr2 : Array
        Positions of the Wiener trajectory with resolution k.
    t_arr2 : Array
        Times of the Wiener trajectory with resolution k.

    """
    
    dt = tmax/(2**(k))
    
    x_arr2 = np.empty((2**k)+1)
    t_arr2 = np.empty((2**k)+1)
    
    for j in np.arange(0,(2**k)+1):
        
        j_int = int(j/2)
        if j % 2 == 0:
            #Condition 4.3a
            x_arr2[j] = x_arr[j_int]
            t_arr2[j] = t_arr[j_int]
            
        else:
            #Condition 4.3b
            mu_int = (x_arr[j_int] + x_arr[j_int+1])/2 
            sigma_int = np.sqrt(2*D*(dt/2))
            x_int = np.random.normal(loc = mu_int, 
                                     scale = sigma_int)
            x_arr2[j] = x_int
            
            t_int = (t_arr[j_int] + t_arr[j_int+1])/2
            t_arr2[j] = t_int
    
    return x_arr2, t_arr2