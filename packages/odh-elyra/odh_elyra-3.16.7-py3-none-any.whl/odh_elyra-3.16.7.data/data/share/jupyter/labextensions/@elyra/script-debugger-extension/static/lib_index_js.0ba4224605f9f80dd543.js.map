{"version":3,"file":"lib_index_js.0ba4224605f9f80dd543.js","mappings":";;;;;;;;;AAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,mBAAO,CAAC,uGAAsB;AACtD,sBAAsB,mBAAO,CAAC,wFAAyB;AACvD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,qBAAqB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iBAAiB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF,sDAAsD,MAAM,KAAK,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAe;AACf","sources":["webpack://@elyra/script-debugger-extension/./lib/index.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2018-2023 Elyra Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst script_editor_1 = require(\"@elyra/script-editor\");\nconst application_1 = require(\"@jupyterlab/application\");\nconst debugger_1 = require(\"@jupyterlab/debugger\");\nconst fileeditor_1 = require(\"@jupyterlab/fileeditor\");\nconst services_1 = require(\"@jupyterlab/services\");\n/**\n * Debugger plugin.\n * Adapted from JupyterLab debugger extension.\n * A plugin that provides visual debugging support for script editors.\n */\nconst scriptEditorDebuggerExtension = {\n    id: 'elyra-script-debugger',\n    autoStart: true,\n    requires: [debugger_1.IDebugger, fileeditor_1.IEditorTracker],\n    optional: [application_1.ILabShell],\n    activate: (app, debug, editorTracker, labShell) => {\n        console.log('Elyra - script-debugger extension is activated!');\n        const handler = new debugger_1.Debugger.Handler({\n            type: 'file',\n            shell: app.shell,\n            service: debug\n        });\n        const activeSessions = {};\n        const kernelManager = new services_1.KernelManager();\n        const sessionManager = new services_1.SessionManager({\n            kernelManager: kernelManager\n        });\n        const updateDebugger = (widget) => __awaiter(void 0, void 0, void 0, function* () {\n            const widgetInFocus = app.shell.currentWidget;\n            if (widget !== widgetInFocus) {\n                return;\n            }\n            const kernelSelection = widget.kernelSelection;\n            const sessions = app.serviceManager.sessions;\n            try {\n                const path = widget.context.path;\n                let sessionModel = yield sessions.findByPath(path);\n                if (!sessionModel) {\n                    // Start a kernel session for the selected kernel supporting debug\n                    const sessionConnection = yield startSession(kernelSelection, path);\n                    sessionModel = yield sessions.findByPath(path);\n                    if (sessionConnection && sessionModel) {\n                        activeSessions[sessionModel.id] = sessionConnection;\n                    }\n                }\n                if (sessionModel) {\n                    let sessionConnection = activeSessions[sessionModel.id];\n                    if (!sessionConnection) {\n                        // Use `connectTo` only if the session does not exist.\n                        // `connectTo` sends a kernel_info_request on the shell\n                        // channel, which blocks the debug session restore when waiting\n                        // for the kernel to be ready\n                        sessionConnection = sessions.connectTo({ model: sessionModel });\n                        activeSessions[sessionModel.id] = sessionConnection;\n                    }\n                    yield updateKernel(sessionConnection, kernelSelection);\n                    // Temporary solution to give enough time for the handler to update the UI on page reload.\n                    setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n                        yield handler.update(widget, sessionConnection);\n                        app.commands.notifyCommandChanged();\n                    }), 500);\n                }\n            }\n            catch (error) {\n                console.warn('Exception: session connection = ' + JSON.stringify(error));\n            }\n        });\n        // Use a weakmap to track the callback function used by signal listeners\n        // The object is cleared by garbabe collector when no longer in use avoiding memory leaks\n        // Key: ScriptEditor widget\n        // Value: instance of updateDebugger function\n        const callbackControl = new WeakMap();\n        const update = (widget) => __awaiter(void 0, void 0, void 0, function* () {\n            if (widget instanceof script_editor_1.ScriptEditor) {\n                let callbackFn = callbackControl.get(widget);\n                if (!callbackFn) {\n                    callbackFn = () => updateDebugger(widget);\n                    callbackControl.set(widget, callbackFn);\n                }\n                updateDebugger(widget);\n                // Listen to possible kernel selection changes\n                widget.kernelSelectionChanged.disconnect(callbackFn);\n                widget.kernelSelectionChanged.connect(callbackFn);\n            }\n        });\n        if (labShell) {\n            // Listen to main area's current focus changes.\n            labShell.currentChanged.connect((_, widget) => {\n                return update(widget.newValue);\n            });\n        }\n        if (editorTracker) {\n            // Listen to script editor's current instance changes.\n            editorTracker.currentChanged.connect((_, widget) => {\n                return update(widget);\n            });\n        }\n        const startSession = (kernelSelection, path) => __awaiter(void 0, void 0, void 0, function* () {\n            const options = {\n                kernel: {\n                    name: kernelSelection\n                },\n                path: path,\n                type: 'file',\n                name: path\n            };\n            let sessionConnection = null;\n            try {\n                if (kernelSelection) {\n                    sessionConnection = yield sessionManager.startNew(options);\n                    sessionConnection.setPath(path);\n                    console.log(`Kernel session started for ${kernelSelection} kernel`);\n                }\n            }\n            catch (error) {\n                console.warn('Exception: start session = ' + JSON.stringify(error));\n            }\n            return sessionConnection;\n        });\n        const updateKernel = (sessionConnection, kernelSelection) => __awaiter(void 0, void 0, void 0, function* () {\n            var _a;\n            try {\n                const prev = (_a = sessionConnection.kernel) === null || _a === void 0 ? void 0 : _a.name;\n                if (kernelSelection && prev !== kernelSelection) {\n                    yield sessionConnection.changeKernel({ name: kernelSelection });\n                    console.log(`Kernel change from ${prev} to ${kernelSelection}`);\n                }\n            }\n            catch (error) {\n                console.warn('Exception: change kernel = ' + JSON.stringify(error));\n            }\n        });\n    }\n};\nexports.default = scriptEditorDebuggerExtension;\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}