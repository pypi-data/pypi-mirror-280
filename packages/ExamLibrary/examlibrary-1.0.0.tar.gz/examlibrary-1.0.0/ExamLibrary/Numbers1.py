from sympy import Symbol, Eq, solve, symbols, diff
#Библиотека SymPy – это библиотека символьной математики для Python. Она позволяет решать символьные вычисления,
# такие как алгебраические уравнения, дифференцирование, интегрирование, упрощение выражений,
# решение систем уравнений и многое другое.

#Класс Symbol из библиотеки SymPy представляет символическую переменную или символ.
# Символьная переменная, созданная с помощью Symbol,
# может быть использована для создания выражений, уравнений,
# функций и других математических объектов в символьной математике.

#Eq - это класс из библиотеки SymPy, который используется
# для представления уравнений в символьной математике.
# "Eq" означает "Equation" (Уравнение)

#Класс solve предоставляет возможность решать уравнения и системы уравнений.
# Для решения уравнения можно использовать функцию solve,
# передавая ей уравнение в качестве аргумента.

#Класс symbols используется для создания символьных переменных.
# Функция symbols принимает строку или список строк в качестве аргументов и создает соответствующие символьные переменные.
# Например, symbols('x y z') создаст символы x, y и z, которые могут быть использованы для построения выражений
# и уравнений в символьной математике.

#Класс diff используется для дифференцирования выражений. Функция diff принимает выражение и переменную,
# по которой нужно дифференцировать, в качестве аргументов.
# Например, diff(x**2, x) вернет производную выражения x**2 по переменной x, то есть 2*x.

#Scipy - это библиотека для научных и инженерных вычислений, построенная на языке программирования Python.
# Она содержит множество полезных функций и инструментов для работы с различными математическими задачами,
# такими как оптимизация, вычисление интегралов, решение дифференциальных уравнений, интерполяция,
# обработка сигналов, обработка изображений и многое другое.

#класс minimize, который предоставляет возможность минимизировать (или максимизировать)
# целевую функцию с использованием различных методов оптимизации.
# Класс minimize является частью модуля scipy.optimize и позволяет решать задачи оптимизации с ограничениями или без них.
def number11():
    #Скорость движения точки задана формулой S = 4t3-2t.
    # Вычислить приближённо изменение скорости, если t=6  увеличено на 0,02,
    # и определить абсолютную погрешность.
    t = 6
    dt = 0.02

    S = 4*t**3 - 2*t
    S_new = 4*(t+dt)**3 - 2*(t+dt)

    delta_S = S_new - S
    absolute_error = abs(8.6 - delta_S)
    round_delta_S = round(delta_S, 2)
    round_absolute_error = round(absolute_error, 2)
    print("Δ =", round_absolute_error)
    print("ΔS =", round_delta_S)

def number12():
    #Разложить число А на два слагаемых так, чтобы их произведение было наибольшим.
    def find_max(A):
        max = 0
        maxi, maxj = 0, 0
        for i in range(A):
            j = A - i
            a = i * j
            if a > max:
                max = a
                maxi, maxj = i, j
        return maxi, maxj
    A = int(input("Введите число A: "))
    result = find_max(A)
    print(f"Два слагаемых для числа {A}, у которых произведение максимально: {result}")

def number13():
    #Прямоугольный участок земли требуется с трёх сторон оградить забором длиной 120 м.
    # Определить размеры участка, чтобы он имел наибольшую площадь
    # Создаем символьные переменные
    x = Symbol('x')
    y = Symbol('y')

    # Уравнение суммы периметра
    eq1 = Eq(2*x + y, 120)

    # Площадь прямоугольника
    area = x*y

    # Решаем систему уравнений
    y_value = solve(eq1, y)[0]
    area = area.subs(y, y_value)

    # Находим производную площади
    darea_dx = area.diff(x)

    # Находим x для максимальной площади
    optimal_x = solve(darea_dx, x)[0]
    optimal_y = solve(eq1.subs(x, optimal_x), y)[0]

    print(f"Размеры участка для наибольшей площади: {optimal_x}, {optimal_y}")

def number14():
    #Для какой из данных функций f1, f2, f3, f4 функция F является первообразной,
    # если F=x5+3x2-10x, f1=6x5+9x2-10x, f2=5x4+6x-10, f3=5x+6x-10x, f4=x6/6+x3-5x2?
    x = symbols('x')

    f1 = 6*x**5 + 9*x**2 - 10*x
    f2 = 5*x**4 + 6*x - 10
    f3 = 5*x + 6*x - 10*x
    f4 = x**6/6 + x**3 - 5*x**2

    F = x**5 + 3*x**2 - 10*x

    # Находим производные
    F1 = diff(F, x)
    F2 = diff(F, x)
    F3 = diff(F, x)
    F4 = diff(F, x)

    if F1 == f1:
        print("Функция f1 = 6x^5 + 9x^2 - 10x имеет первообразную F = x^5 + 3x^2 - 10x")
    elif F2 == f2:
        print("Функция f2 = 5x^4 + 6x - 10 имеет первообразную F = x^5 + 3x^2 - 10x")
    elif F3 == f3:
        print("Функция f3 = 5x + 6x - 10x имеет первообразную F = x^5 + 3x^2 - 10x")
    elif F4 == f4:
        print("Функция f4 = x^6/6 + x^3 - 5x^2 имеет первообразную F = x^5 + 3x^2 - 10x")

def number15():
    import sympy as sp
    #Исследовать функцию на экстремум с помощью второй производной y=6x-x2.
    # определяем символьную переменную
    x = sp.Symbol('x')

    # задаем функцию y
    y = 6*x - x**2

    # находим первую производную
    y_prime = sp.diff(y, x)

    # находим вторую производную
    y_double_prime = sp.diff(y_prime, x)

    # решаем уравнение для первой производной y' = 0
    critical_points = sp.solve(sp.Eq(y_prime, 0), x)

    # находим значение второй производной в критических точках
    extremum_points = []
    for point in critical_points:
        if y_double_prime.subs(x, point) < 0:
            extremum_points.append(point)

    print(f"Точка(и) экстремума: x = {extremum_points} - точка максимума")

def number16():
    from scipy.optimize import minimize
    #Требуется вырыть яму объёмом 32 м3, имеющую квадратное дно так,
    # чтобы на облицовку её дна и стен пошло наименьшее количество материала.
    # Каковы должны быть размеры ямы?
    def objective_function(x):
        h = 32 / x**2
        return x**2 + 4 * x * h

    # Начальное предположение для x
    initial_guess = 1
    result = minimize(objective_function, initial_guess)

    # Извлекаем результаты
    optimal_x = result.x[0]
    optimal_h = 32 / optimal_x**2

    print(f"Стоит вырыть яму с размерами: сторона дна = {round(optimal_x)}, высота = {round(optimal_h)}")

def number17():
    #Точка движется прямолинейно по закону S = 2t3+t2-4.
    # Найти её скорость в момент времени t=4.
    def velocity(t):
        return 6*t**2 + 2*t

    # Вычисляем скорость в момент времени t=4
    t = 4
    v = velocity(t)

    print(f"Скорость точки в момент времени t=4: {v}")

def number18():
    #Материальная точка движется по закону S = 2t3-6t2+4t.
    # Найти её ускороение в конце 3-й секунды.
    def acceleration(t):
        return 12*t - 12

    # Вычисляем ускорение в конце 3-й секунды (t=3)
    t = 3
    a = acceleration(t)

    print(f"Ускорение материальной точки в конце 3-й секунды: {a} м/с^2")

    print('\nФункция для нахождения производных')
    from sympy import symbols, diff
    def find_derivative(expression, variable):
        x = symbols(variable)
        derivative = diff(expression, x)
        return derivative

    # Пример использования функции для нахождения производной
    expression = 'x**2 + 2*x + 1'  # Пример функции x^2 + 2x + 1
    variable = 'x'  # Переменная по которой берется производная

    derivative = find_derivative(expression, variable)
    print(derivative)